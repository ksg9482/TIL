HTTP - HTML을 주고 받을 때 서로 지키기로 정한 규칙. 서버와 클라이언트가 주고 받는 메시지가 노출되어 있어서 탈취, 위조의 위험이 있다.
비상태성 - 클라이언트에서 전달한 데이터를 저장하지 않는다. 즉, 상태를 보존하지 않는다.
비연결성 - 연결을 유지하지 않는다. 한번의 통신이 끝나면 다시 연결해야 한다.

HTTPS - HTTP의 보안을 강화한 것. 암호화된 연결로 웹 서버와 통신한다. SSL(TLS. Transport Layer Security)를 통해 HTTP 메시지를 암호화 한다.

SSL - 개인키와 공개키를 사용하고 제3자를 인증기관으로 이용해 보안을 강화하며 데이터를 암호화 한다.

암호화 - 정보를 허락된 사람들만 볼 수 있도록 알고리즘을 이용해 정보를 암호문으로 바꾼다. 이때 사용하는 비밀번호와 같은 것을 키(key)라고 한다.

대칭키 - 암호화 할 때 사용한 키를 복호화 할 때도 그대로 사용함. 정보를 암호화 한 후에 암호화에 사용한 키도 전달한다.

비밀키(개인키)와 공개키 - 비대칭키. 공개키는 노출되어 있으며 공개키를 이용하여 암호화 하면 비밀키를 가진 사람만이 이 정보를 복호화 할 수 있다. 반대로 비밀키로 암호화 할 수 있는데 이런식의 암호화를 이용하여 신원을 증명하는 방식을 전자서명이라 한다.

SSL 동작 방식 - 서버가 신회할 수 있는 사이트임을 확인한 클라이언트는 서버와의 핸드셰이크 단계에서 주고 받은 랜덤데이터를 이용해 키를 생성. 이 키를 대칭키 방식으로 사용. 인증서 안에는 서비스와 서버의 공개키가 들어있고, 대칭키를 이 공개키로 암호화 한 후 서버에 보내면 비밀키를 가진 서버만 대칭키를 복호화 할 수 있다. 대칭키를 이용하여 정보를 교하고 사용된 대칭키는 SSL접속이 끝나면 폐기 된다.

TCP (Transmission Control Protocol) - 연결 지향형 프로토콜. 3-way handshaking 과정을 통해 신뢰성을 보장하도록(흐름 제어, 혼잡제어, 오류제어) 하는 프로토콜이다. 연결을 종료할 때는 4-way handshaking을 사용한다. UDP에 비해 느리다. HTTP통신, 이메일 등에 사용.

UDP (User Datagram Protocol) - 데이터를 데이터그램 단위로 전송하는 프로토콜. 순서를 보장하지 않고 신뢰도가 낮은 데이터 통신을 하는 대신 단방향 데이터 전송으로 속도가 빠르다. 스트리밍등 연속성이 더 중요한 서비스에 사용된다.

HTTP 메서드 - GET - 리소스의 조회를 할 때 사용하고 몇번을 재요청해도 결과가 같은 멱등성이 보장된다. POST - 바디에 내용을 담아 보낼 수 있고, 멱등성을 보장하지 않는다.

TCP 3, 4 way handshake
3-way handshake는 TCP통신을 확립하기 위한 단계. 클라이언트를 서버에 요청을 전송할 수 있는지, 서버는 클라이언트에 응답을 전송할 수 있는지 확인한다.
SYN, ACK패킷을 주고받으며 임의의 난수로 SYN플래그, ACK 플래그에는 1을 더한값을 전송한다. 임의의 난수를 전송하는 이유는 기존의 요청과 구분하기 위해.

4-way handshake는 TCP통신을 해제하기 위한 단계. 클라이언트는 서버에 연결 해제 통지, 서버는 해제 통지를 받았음을 전송하여 최종적으로 연결이 해제. 4way인 이유는 마지막에 FIN메시지를 전송하기 때문. 해제해도 클라이언트는 일정시간 대기하는데 패킷이 나중에 도착할 수 있기 때문.

SSL handshake - 클라이언트는 TCP 3 way handshake를 수행한 후 Client Hello 전송. 서버가 인증서를 전송하면 클라이언트는 인증서가 등록된 인증기관인지 확인. 브라우저가 인증서를 검증하여 사이트의 정보와 서버의 공개키를 얻으면 서버의 공개키로 통신에 사용할 비밀키를 암호화해서 서버에 전송.
서버는 개인키로 이를 확인하고 이후는 공유된 비밀키로 암호화된 통신을 실시.
공개키와 비밀키 암호화를 복합적으로 사용하는 이유는 서로의 장단점을 보완할 수 있기 때문. 대칭키는 암복호화 하는 키가 똑같아 연산이 빠르지만 대칭키가 유출되면 암호화가 쉽게 풀린다. 공개키는 암복호화 키가 서로 달라 연산이 느리지만 보안이 강하다. 때문에 두 방식을 혼용한다. 

웹 통신의 큰 흐름
브라우저가 URI에 적힌 값을 파싱해서 HTTP Request Message 생성하고 OS에 전송 요청.
브라우저 -> hosts파일 -> DNS캐시의 순서로 DNS룩업을 통해 도메인에 매칭되는 ip검색. 없으면 DNS서버를 검색하고, 다시 재귀식으로 ip를 검색.
요청은 인터넷으로 이동하여 목적지까지 전송된다. 목적지에 도달하면 방화벽의 검사를 통과한 후 캐시 서버에 도달하여 웹서버에 도달해야 하는지 검사.
웹서버에 도달하면 메시지를 복원하여 웹 서버 어플리케이션에 전달. 어플리케이션은 요청에 대한 응답을 작성하여 반환하고, 전달되었던 방식대로 요청을 보냈던 클라이언트에게 전송된다.

TCP/IP 프로토콜 4계층 - 인터넷 기반의 효율적인 데이터 전송을 위한 프로토콜의 모음. 가장 상위부터 응용, 전송, 인터넷, 네트워크 엑세스 계층이다.
응용 계층 - HTTP, FTP 가 예. TCP/UDP 기반의 응용프로그램을 구현 할 때 사용. 
전송 계층 - TCP, UDP가 예. 통신 노드간 연결을 제어하고 데이터 전송을 담당.
인터넷 계층 - 통신 노드 간 IP 패킷을 전송하는 것과 라우팅 하는 기능을 담당.
네트워크 액세스 계층 - 네트워크의 하드웨어 제어를 담당.
OSI 1,2계층: TCP/IP 1계층. OSI 3계층: TCP/IP 2계층. OSI 4계층: TCP/IP 3계층. OSI 5,6,7계층: TCP/IP 4계층. 

OSI 7계층 - 네트워크를 구성하는 요소들을 7계층으로 표준화한 것. 통신에서 일어나는 일을 단계별로 파악할 수 있어 문제 발생시 문제가 일어난 영역을 좁힐 수 있다.
7계층: 어플리케이션 계층. 통신의 최종 목적지. HTTP프로토콜이 7계층에 속한다. 응용프로그램과 관계하여 일반적인 응용서비스를 수행한다.
6계층: 표현 계층. 코드간의 번역을 담당하여 데이터의 형식 차이를 다루는 부담을 응용 계층에서 덜어준다. 데이터가 텍스트인지 이미지인지의 구분등이 6계층의 몫이다.
5계층: 세션 계층. 데이터 통신을 위한 논리적 연결을 담당한다. 통신을 위한 세션을 확립/유지/중단을 책임진다. TCP/IP 세션을 만들고 없애는 것이 5계층이다.
4계층: 전송 계층. 통신을 활성화 하기 위한 계층. 보통 TCP프로토콜을 이용하고, 데이터가 오면 4계층에서 합쳐 5계층에 전달한다.
3계층: 네트워크 계층. 경로를 선택하고 주소를 정하고 경로에 따라 패킷을 전달한다. 데이터를 목적지까지 안전하고 빠르게 전달하는 라우팅을 담당한다.
2계층: 데이터링크 계층. 물리 계층을 통해 전달되는 정보의 흐름을 관리하여 안전한 정보의 전달을 수행할 수 있게 한다. MAC주소로 통신하는 계층이다. 데이터링크 계층의 대표적인 예는 이더넷이다.
1계층: 물리 계층. 전기, 기계적 특성을 이용하여 통신 케이블로 데이터를 전송한다.

웹 서버 소프트웨어(Apache, Nginx)는 어플리케이션 계층인 7계층에서 작동한다.

HTTP 비연결성 (Connectionless) - 클라이언트 요청에 대해 서버가 응답을 한 후 바로 연결이 끊어지는 특징. 연결이 해제됨과 동시에 서버와 클라이언트는 이전에 요청한 결과를 잊어 상태를 유지하지 않는 무상태성(Stateless)의 특징을 띄기도 한다. 서버의 부담을 줄일 수 있지만 사용자 상태를 유지시킬 수 없기 때문에 세션이나 쿠키등이 필요하다.

세션 - 서버 측에 정보 저장. 타인에게 노출되어서는 않되고 서비스 제공자가 직접 관리해야 하는 정보를 저장한다. 세션에 저장된 정보가 너무 많으면 서버 부담이 커진다.
쿠키 - 클라이언트 측에 정보 저장. 사용자의 편의를 위하되 삭제, 탈취 당해도 큰 문제가 생기지 않을 정보를 저장한다.
토큰 - 인증에 필요한 정보를 암호화 시킨 토큰을 이용. 액세스 토큰을 HTTP 헤더에 실어 서버에 전송한다. 임의로 생성된 비밀번호와 같이 동작하며 제한된 수명을 가지고 있고, 만료되면 재생성 해야 한다.

쿠키의 보안 - Sesure - HTTPS가 아니면 쿠키를 전송하지 못하게 한다. HTTP Only - 서버 요청이 있을 때에만 쿠키가 전송되도록 하고 임의로 브라우저에 출력되지 않게 한다.

CORS (Cross_Origin Resource Sharing) - 출저가 다른 리소스도 공유할 수 있도록 하는 정책. 보안상 이유로 출처가 같은 리소스만 공유(Same-Origin Policy)할 수 있지만, CORS 정책을 지키는 리소스 요청이라면 다른 출처의 리소스와도 상호작용을 허용한다. 클라이언트가 요청메시지의 Origin 헤더에 해당 출처를 적어 보내고, 응답으로 받은 메시지의 Access-Control-Allow-Origin의 내용을 자신이 보냈던 Origin 헤더의 내용과 비교한다.

REST - 자원을 이름으로 구분하여 해당자원의 상태를 주고 받는다. 자원, 행위, 표현으로 구성되는데 HTTP URI를 통해 자원을 명시하고 HTTP Method를 통해 해당 자원에 CRUD를 적용한다.
RESTful - REST라는 아키텍처를 구현하는 웹서비스를 나타내는 용어. REST API를 제공하는 웹서비스를 RESTful하다고 한다.

API (Application Programming Interface) - 데이터와 기능의 집합을 제공해 컴퓨터 프로그램간 상호작용을 할 수 있게 한 것.

WS - 정적 파일을 제공하기 위한 서버로 HTTP 프로토콜에 의해 제공. 정적 파일로만 처리 가능한 것은 WAS로 요청을 넘기지 않고 바로 요청 처리. 
WAS - 동적인 데이터를 제공하기 위한 서버. 웹서버에서 처리할 수 없는 동적인 정보를 처리하여 웹서버에 정적인 정보를 제공한다.

클라우드 - 타사 제공업체가 호스팅하여 인터넷을 통해 사용자에게 제공하는 인프라, 플랫폼, 소프트웨어. 인터넷에 연결된 다른 컴퓨터의 자원을 빌려 활용한다.
IaaS - 서비스로서의 인프라. 사용자에게 컴퓨팅, 네트워크, 스토리지 자원 제공.
PaaS - 서비스로서의 플랫폼. 어플리케이션을 실행 할 수 있는 플랫폼과 플랫폼 실행에 필요한 인프라 제공.
SaaS - 서비스로서의 소프트웨어. 작동하는 어플리케이션과 그 어플리케이션을 실행할 수 있는 플랫폼, 플랫폼의 기반 인프라 제공.
FaaS - 서비스로서의 기능. 개발자가 인프라를 유지 관리 하지 않고도 어플리케이션과 기능을 구축하고 관리할 수 있도록 지원.

Status Code
200 - OK. 요청을 성공적으로 수행
201 - Created. 요청을 성공적으로 수행하고, 그 결과로 새로운 리소스 생성
204 - No Content. 요청을 성공적으로 수행하고, 그 결과로 리소스가 삭제

400 - Bad Request. 사용자의 잘못된 요청을 처리할 수 없음
401 - Unauthorized. 인증이 필요한 페이지 요청
403 - Forbidden. 접근 권한이 없음
404 - Not found. 요청한 페이지-리소스 없음
405 - Method not allowed. 허용되지 않은 HTTP Method 사용
408 - Request Timeout. 요청 시간 초과

500 - Internal server error. 내부 서버 오류
502 - Bad Gatesay. 게이트웨이 오류


도커 - 컨테이너 기반 오픈소스 가상화 플랫폼. 독립적 환경에서 일관된 결과를 보여준다. 그러나 초반 환경 설정시 시행착오를 겪을 수 있고, 리눅스에 친화적이기 때문에 플랫폼에 의존적이게 된다.

로드 밸런서 - 클라이언트와 서버 사이에 존재하며, 서버의 스케일 아웃을 높일 수 있다. 로드 밸런서에 문제가 생길 경우 전체 서비스가 작동하지 않는다. OSI 4계층에서 동작하는 것과 OSI 7계층에서 동작하는 것이 있다. 4계층에서 동작하는 로드밸런서는 자세하게 설정하지 못하지만 비용이 낮고, 7계층에서 동작하는 로드밸런서는 자세하게 설정이 가능하지만 비용이 높다.

NodeJS - 브라우저가 아닌 곳에서 자바스크립트를 동작시키기 위한 런타임. 
자바스크립트 - 인터프리터 언어이기 때문에 바이트언어로 변환되어 가상머신을 통제한다. 이벤트루프를 기반으로 동작하며, 프로토타입 기반 언어, 비동기I/O, 단일스레드로 작동한다. 

이벤트 루프 - 자바스크립트는 하나의 호출스택을 갖는 싱글 스레드 언어이다. 이벤트루프 기반의 비동기 방식으로 Non-blocking I/O를 지원. 비동기 함수 실행시 task-queue에 등록되고 이벤트루프 바깥에서 코드가 실행되고, 그 후 이벤트루프를 확인해 남은 작업이 있다면 실행한다. 여러 페이즈로 나누어져 있고 각 페이즈는 담당으로 정해진 작업만 관리한다.

var와 let, const차이 - var는 es6이전의 변수할당 문법이고, let과 const는 es6문법이다. let과 const는 호이스팅시 실질적으로 호출되는 곳까지 도달하지 않으면 초기화되지 않기 때문에 선언된 라인 이전에 값을 사용할 수 없다.

스코프 - 식별자의 유효범위. 선언된 위치에 따라 유효범위가 달라진다. 전역 스코프는 어디에서든 참조할 수 있지만, 지역 스코프는 자신의 지역과 그 하위 지역에서 유효하다. 모든 코드블록(if, for, try/catch 등)은 지역 스코프를 만들며 이런 지역 스코프를 블록레벨 스코프라고 한다.

렉시컬 스코프 - 함수의 상위 스코프를 결정하는 방식으로 함수를 어디서 선언했는지에 따라 상위 스코프를 결정한다.

Promise - 비동기 처리에 사용되는 객체. resoleve 함수와 reject함수를 인자로 받을 수 있고, 성공시 resoleve 함수를 호출하고, 실패시 reject함수를 호출한다.

실행 컨텍스트
자바스크립트 코드가 실행되면 모든 변수를 포함하는 실행 컨텍스트를 생성한다. 이는 모든 것을 관리하는 환경이고 종료시까지 유지된다.
크게 전역 컨텍스트와 함수 컨텍스트가 있는데 자바스크립트를 실행하면 단 하나의 전역 컨텍스트가 생성되고 함수가 실행될 때마다 함수 컨텍스트가 생성된다.

호이스팅 - 코드 하단에 선언한 변수가 마치 코드 최상단에 선언한 것처럼 취급되는 현상.
실행컨텍스트 생성시 모든 변수의 선언을 먼저하기 때문에 코드 하단부에 있는 변수가 끌어올려지는 것처럼 보인다.

함수의 경우 함수 선언식은 통째로 호이스팅 되지만 함수 표현식은 호이스팅되지 않는다.

let이나 const로 선언한 변수는 초기화되기 전까지는 접근 할 수 없는 TDZ 상태에 있게 된다. 여기서 말하는 초기화는 변수 선언을 말한다.
const는 변수 선언시 값을 할당해야 하지만, let은 선언시 undefined가 할당되어 있다.

클로저 -함수와 함수가 선언된 언휘적 환경의 조합. 간단하게는 외부함수가 포함하고 있는 변수에 접근할 수 있는 내부함수. 함수 내부에 선언된 함수는 렉시컬 스코프에 따라 내부 함수의 상위 스코프는 외부함수이다. 
외부 함수의 바깥에선 외부함수가 포함한 변수에 접근하지 못하지만, 외부 함수의 안에 있는 내부 함수는 변수에 접근 할 수 있다. 이는 실행 컨텍스트의 스코프 체인을 자바스크립트 엔진이 검색했기 때문에 가능하다.
내부 함수의 스코프에서 변수 x를 검색하고 없다면, 상위 스코프인 외부 함수에서 변수x를 검색하는 식이다. 이 스코프 체이닝은 전역변수에 이를때까지 연결된다.

클로저는 자신이 생성될 때의 환경을 기억하는 함수라고 볼 수도 있다. 외부 함수가 종료되어도 외부 함수의 실행 컨텍스트는 내부 함수가 참조하는 한 유효하여 계속 유지된다.

클로저가 가장 유효하게 사용되는 상황을 현재 상태를 기억하고 변경된 최신 상태를 유지하는 것. 상태를 유지하기 위해 전역변수를 이용하지 않아도 된다.
그러나 메모리를 소모하고, 스코프 생성에 따른 퍼포먼스 손해가 있다. 

DB 키 종류
후보키 - 유일성(해당 키로 하나의 튜플을 식별가능)과 최소성(꼭 필요한 속성으로만 이루어짐)을 만족한 키.
기본키 - 후보키 중 하나. Null값, 중복값을 가질 수 없다.
대체키/보조키 - 기본키를 제외한 후보키
외래키 - 다른 릴레이션의 속성, 참조 관계를 표현하는데 사용
슈퍼키 - 유일성은 만족하나 최소성은 만족하지 못하는 키

조인(JOIN) - 두 가지 이상의 릴레이션을 연결해서 데이터를 검색하는 기법. RDBMS에서는 릴레이션끼지 관계를 가지고 있는데 각 테이블에 저장된 데이터를 효과적으로 검색하기 위해 조인이 필요하다.
Inner Join - 기본적인 조인
Outer Join - 특정 테이블의 데이터가 모두 필요한 경우
Self Join - 자기 자신과 자기 자신 결합

SQL injection 해커에 의해 조작된 쿼리문이 DB에 그대로 전달되어 비정상적인 명령을 실행시키는 공격 기법

ORM - Object-Relation Mapping. 객체-관계 매핑. 객체지향적인 코드로 비즈니스 로직에 집중 가능. 재사용 및 유지보수를 용이하게 하고, DBMS에 대한 종속성을 감소시킨다. 

RDB - 관계형 데이터베이스. 데이터가 하나 이상의 열과 행으로 구성된 테이블에 저장되고, 서로 다른 데이터 구조물이 어떻게 관계되어 있는지 표현한다.

트랜잭션 - 여러개의 작업을 하나로 묶은 실행 단위. 다 성공하거나 다 실패하거나. 하나라도 실패하면 트랜잭션 자체가 실패한다.

ACID - 데이터베이스 내부에서 일어나는 하나의 트랜잭션의 안정성을 보장하기 위해 필요한 성질. 발생할 수 있는 예외사항을 줄이고, DB의 무결성을 보호할 수 있다.
A - Atomicity 원자성. 한 트랜잭션의 연산이 모두 성공하거나 하나라도 실패하면 트랜잭션 자체가 실패하는 성질.
C - Consitency 일관성. 한 트랜잭션 이후에 그 이전처럼 DB의 제약과 규칙을 만족해야 한다.
I - Isolation 고립성. 한 트랜잭션은 다른 트랜잭션으로부터 독립되어야 한다.
D - Durability 지속성. 한 트랜잭션이 성공적으로 수행되었으면 DB에 반영되어야 한다.

스키마 - DB의 구조와 제약조건에 관해 명세를 기술한 것.

View - 가상 테이블. 보안, 편의, 수행속도 향상을 목적으로 한다. 필요한 데이터만 뷰로 정의 할 수 있고, 독립적 인덱스가 불가능하다.

정규화 - RDB에서 중복을 최소화하기 위해 데이터를 분해하는 작업을 말한다. 이상현상을 방지할 수 있다는 장점이 있지만, 릴레이션 간의 연산이 많아질 수 있다는 단점이 있다.

반정규화 - 성능향상을 위해 중복, 통합을 하는 기법. JOIN으로 인해 성능저하가 예상되는 경우 실행하지만, 과도할 경우 무결성이 깨질 수 있다.

정규화 이상 - 데이터의 중복으로 인한 부작용
삽입 이상 - 데이터를 삽입하는 데 필요없는 속성도 함께 추가해야 함
갱신 이상 - 데이터를 갱신한 이후 일관성이 위반됨
삭제 이상 - 데이터를 삭제하는 데 의도하지 않은 것이 함께 삭제되어 정보손실이 일어남

인덱스 - 검색 연산의 속도를 높이기 위한 방법. 항상 정렬된 상태를 유지하므로 탐색이 빠르지만, 데이터 삽입/수정/삭제 시에는 추가적인 작업이 필요하므로 실행속도가 느려진다.

Commit - 모든 작업을 정상적으로 처리하겠다고 확정하는 명령. 실제 DB에 저장. 수행 후 하나의 트랜잭션이 종료된다.
Rollback - 작업 중 문제가 발생하면 변경사항을 취소하고 트랜잭션을 종료한다. 이전 Commit까지만 복구.


### MongoDB
NoSQL - RDB의 테이블 구조와는 다른 형태로 데이터를 저장한다. MongoDB는 문서형태로 데이터를 저장하고 Redis는 key-value형태로 데이터를 저장한다.

MongoDB는 C++로 제작된 문서지향 오픈소스 NoSQL 데이터베이스. 비정형 데이터를 JSON형식으로 데이터를 저장한다.

DB에서 데이터를 검색하기 위해 필드, 범위기반, 문자열 패턴 일치 등 쿼리를 지원.
기본적으로 프로시저 대신 JavaScript 객체를 사용하며 동적 데이터베이스 스키마를 사용한다.

확장 또는 축소가 쉽고 데이터 파티셔닝 지원기능이 내장되어 있다.

* 문서 - 관련 값이 있는 정렬된 키/값쌍의 집합. 맵 또는 해시로 표시되고 JavaScript에서 문서는 객체로 표시된다.
* 컬렉션 - 문서 그룹. RDB의 테이블에 해당한다. 동적 스키마이기 때문에 여러 모양의 문서를 단일 컬렉션에 저장할 수 있다.
* 몽고 쉘 - 명령줄에서 MongoDB 인스턴스와 상호작용하는 JavaScript 쉘. 이를 통해 관리 및 인스턴스 검사, MongoDB 탐색을 할 수 있고 임의의 JavaScript 프로그램을 실행 할 수 있다.
* 스케일 아웃 - 샤딩은 여러 물리장비에 데이터를 분산하는 방법으로 MongoDB는 샤딩을 통해 스케일 아웃을 진행한다. 데이터 셋을 여러 서버로 나누고 각 서버 인스턴스에 데이터베이스 로드를 분산한다.
대표적으로 Shard, Mongos, Config servers 3요소가 필요하다.
  * Shard - 가장 기본이 되는 인스턴스로 데이터의 하위 집합을 보유한 단일 MongoDB 인스턴스. 여러 샤드를 구성하여 가용성을 높인다.
  * Mongos - 다수 구성된 샤드의 인터페이스 역할, 클라이언트 요청의 올바른 샤드로 라우팅하는 것이 주요 기능.
  * Config servers - 전체 클러스트의 메타 데이터, 구성 설정 등을 저장하는 서버.
  * 어플리케이션은 실행할 쿼리에 대해 라우터(Mongos)와 통신, Mongos는 구성 서버를 참조하여 필요한 데이터 셋이 포함된 샤드를 확인, 쿼리결과가 응용 프로그램에 반환된다.
  * 장점 - 쿼리가 분산되므로 부하 감소, 스토리지 확장에 유리, 서버 노드를 추가하여 클러스터의 성능을 확장 할 수 있다.
  * 단점 - 복잡하기 때문에 신중한 계획과 유지 관리 필요, 분할 해제할 방법이 없다. 특정 명령은 샤딩된 환경에서 지원되지 않는 등 운영 제한이 있다.
* 샤딩 - MongoDB 샤딩은 전체 성능에 큰 영향을 주지 않고 여러 서버에 워크로드를 분산하여 대용량 데이터를 효율적으로 관리하는 방법. 기본 하드웨어 인프라를 복잡하게 재구성하지 않고도 향후 요구 사항에 맞게 클러스터를 효율적으로 확장할 수 있는 기능을 제공.
* MongoDB의 기능 - 인덱싱, 집계, 특별한 유형의 인덱스, 파일 스토리지, 샤딩 등
  * 인덱싱 - 일반적인 보조 인덱스 지원. 고유, 복합, 텍스트 인덱싱 등의 기능도 제공.
  * 집계 - 데이터처리 파이프라인 개념을 기반으로 집계 프레임워크 제공.
  * 특별한 유형의 인덱스 - 특정 시간에 만료되어야 하는 데이터에 대해 TTL(time-to-live) 기능 지원.
  * 파일 스토리지 - 대용량 파일 및 파일 메타데이터를 저장하기 위해 사용하는 프로토콜 지원.
  * 샤딩 - 데이터를 머신간에 분할하는 프로세스.
* 데이터를 추가하는 방법 - 데이터를 추가하는 기본 방법은 'inserts'이다. 단일 문서를 삽입하려면 컬렉션의 inserOne 메서드를 사용한다.
* 데이터를 업데이트 하는 방법 - updateOne, updateMany, replaceOne 등을 사용한다. update는 첫번째 파라미터로 필터링하고 두번째 파라미터로 변경내용을 설명하지만, replace의 두번째 파라미터는 문서를 교체한다.
* 데이터를 삭제하는 방법 - deleteOne과 deleteMany를 사용한다. 두 메서드 전부 첫번째 파라미터를 필터로 사용한다.
* 데이터를 검색하는 방법 - find를 통해 쿼리를 실행한다. 첫번째 파라미터를 통해 쿼리 기준을 설정하면 기준에 맞는 문서를 반환한다.
* 데이터 유형 - number, string, null, date, array, 정규표현, 임베디드 문서, 오브젝트ID, 바이너리 데이터, 코드
* 언제 사용하는가 - 신속한 확장이 필요하거나 데이터 구조의 잦은 변경, 비구조적인 데이터를 저장해야할 경우
* 인덱스 - 데이터 세트의 작은 부분을 이동하기 쉬운 형태로 저장한다. 지정된 필드 값에 따라 특정 필드 또는 필드 세트의 값을 정렬해 저장한다. 일반적인 RDB의 인덱스와 비슷하게 동작한다.
* set 사용법 - 필드 값이 존재하지 않으면 $set을 통해 값을 설정한다. 스키마를 업데이트 하거나 키를 추가할 때 유용하다.(updateOne의 두번째 파라미터에 {"$set" : {"aaa" : "bbb"}} 형식)
* 트랜잭션 - 읽기 또는 쓰기 작업을 수행하는 논리적인 처리 단위. 지정된 작업을 완료하고 commit 하거나 에러가 발생해 작업을 완료하지 못하면 rollback한다.

## 객체 지향
OOP(Object Oriented Programming) - 속성과 행위를 객체라는 하나의 단위로 묶고, 그 객체들의 조합으로 프로그램을 구현하는 방식. 객체지향은 객체가 중심이 되며 어떤 객체가 어떤 일을 할 것인가가 핵심이 된다. 

* 캡슐화 - 객체가 독립적으로 역할을 할 수 있도록 데이터와 기능을 하나로 묶어 관리하고, 구현되는 부분을 외부에 드러나지 않도록하여 내부 정보를 은닉한다.
* 상속 - 하나의 객체가 가진 특징을 다른 객체가 이어받는 것. 코드의 재사용성을 높인다.
* 추상화 - 구체적인 정보에 의존하는 것이 아니라 각 객체가 가진 공통적인 특징에 의존하는 것. 
* 다형성 - 같은 클래스로 여러 종류의 오브젝트를 만들 수 있는 성질. 보통 오버라이딩과 오버로딩을 통해 다형성을 지원한다.
  * 오버 라이딩 - 상위 객체가 가진 메서드를 하위 객체가 재정의해서 사용한다.
  * 오버 로딩 - 객체의 매개변수 이름과 유형을 다르게 갖게 하여 같은 이름의 메서드를 여러가지로 사용하게 하는 방법

### SOLID
* S - Single Responsibility Principle. 단일 책임 원칙. 하나의 모듈은 한가지 책임을 져야한다. 모듈이 변경되는 이유가 한가지여야 한다.
* O - Open-Closed Principle. 개방 폐쇄 원칙. 확장에 대해서는 열려있고, 변경에 대해서는 닫혀 있어야 한다. 요구사항이 변경될 때 새 동작을 추가하여 기능을 확장할 수 있지만, 기존의 코드를 수정하지 않고 추가하거나 변경할 수 있다.
* L - Liskov Substitution Principle. 리스코프 치환 원칙. 하위 타입은 상위 타입을 대체할 수 있어야 한다. 상위 타입이 하위타입으로 변경되어도 상위 타입의 인터페이스를 통해 서브 클래스를 사용할 수 있어야 한다.
* I - Interface Segregation Principle. 인터페이스 분리 원칙. 객체가 높은 응집도의 작은 단위로 설계되어도 목적과 관심이 다른 클라이언트가 있다면 인터페이스를 통해 적절히 분리해주어야 한다.
* D - Dependendy Inversion Principle. 의존 역전 원칙. 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안되며, 고수준 모듈은 변경이 적은 추상화된 클래스이고 저수준 모듈은 변하기 쉬운 구체 클래스이다.


OOP와 함수형 프로그래밍의 가장 큰 차이점 - 상태여부. 객체지향은 객체 안에 상태를 저장하고, 이 상태를 메서드를 통해 조작하는 데 초점을 맞춘다. 함수형 프로그래밍은 상태를 제어하는 것이 아니라 상태를 없애는 데 초점을 맞춘다.

## 타입스크립트
자바스크립트의 수퍼셋이라 자바스크립트 코드를 이용할 수 있고, 정적 타이핑 언어이므로 컴파일시 타입 체크를 실시하기 때문에 런타임 전 타입관련 오류를 예방할 수 있다.

클래스와 인터페이스를 지원하는 객체 지향 패러다임.
변수를 선택적으로 전달해 줄 수 있다.
그러나 컴파일에 시간이 소요되고, 타입스크립트를 지원하지 않는 라이브러리를 이용하려면 추가적인 작업이 필요하다.


기본자료형 - number, string, boolean, null, undefined, void, symbol

변수선언법
1. 변수에 타입과 값을 선언한다. 2. 변수와 타입만 선언한다. (const는 값을 선언해 초기화 해야 한다) 3. 변수와 값만 선언한다. (타입을 선언하지 않으면 암묵적 any타입이 부여된다.) 4. 변수만 선언한다. 

타입스크립트의 함수 오버로딩
1. 파라미터를 여러개 두어서 함수 구분 2. 같은 파라미터로 여러 타입을 받아야 할 경우 typeof 이용.

데코레이터 - @표현식을 이용한다. 데코레이터도 일종의 함수로 클래스, 메서드, 속성, 파라미터등에 적용할 수 있고 tsconfig.json 속성을 추가해야 한다.

왜 타입을 선언해서 지정해야 하는가 - 선언하지 않으면 암묵적인 any 타입으로 취급되고, any타입은 타입체커를 무력화하여 타입으로 인한 오류를 예방한다는 타입스크립트의 목적을 달성할 수 없게된다.

nestjs - NodeJS 측의 약점인 아키텍처의 부재를 해결해준다. 모듈 아키텍처를 채택해여 확장 가능하고 느슨한 결합을 제공한다. 모듈 단위로 결합하기 때문에 컨트롤러나 서비스를 모듈 내에서 관리할 수 있고 OOP의 특징인 갭슐화를 간단하게 구현할 수 있다. 

인터페이스 - 객체가 가질 수 있는 데이터 유형과 기능을 지정하는 것.

null과 undefind의 차이 - undefind는 변수가 초기화 없이 선언되었을때 할당된다. 반대로 null은 의도적으로 값이 없음이라는 내용을 할당하는 것.

void타입과 never타입의 차이 - void는 정의되지 않은 값을 암시적으로 반환한다. 따라서 아무것도 반환하지 않아도 암묵적으로 undefind를 반환하지만, never타입은 절대 값을 반환하지 않거나 항상 throw를 통해 예외를 발생시키는 경우 사용하여 undefind도 반환하지 않는다.

화살표함수 - 함수를 선언하기 위한 짧고 간단한 구문. 화살표 함수는 this가 존재하지 않기 때문에 상위 스코프의 this를 참조한다.

익명함수 - 이름이 없는 함수. 일반적으로 콜백으로 이용된다.

유니온 타입 - 값이 여러 타입중 하나일 수 있다는 의미.

유틸리티 타입 - 타입 변환을 쉽게 할 수 있도록 타입스크립트 자체에서 제공하는 유틸리티. 




미들웨어
서로 다른 어플리케이션이 통신하는데 샤용되는 소프트웨어. 양 쪽을 연결해서 데이터를 주고 받을 수 있도록 중간에서 매개 역할을 한다.
웹 개발에서는 클라이언트와 백엔드 사이에서 요청과 응답에 개입하는 소프퉤어를 말한다.

사용이유
* 다양한 백엔드 리소스에 대한 연결 관리
  * 백엔드 데이터베이스에 대한 빠르고 효율적인 액세스를 위한 연결풀 생성
* 클라이언트의 요청에 따라 로직을 구현
  * 브라우저의 언어 헤더를 인식하고 해당 언어 기반의 결과를 반환하는 등의 기능
* 동시처리, 로드 밸런싱, 트랜잭션 관리
  * 두 개 이상의 클라이언트가 동시에 백엔드 리소스에 액세스 또는 업데이트를 시도할 때 등의 동시성 문제 처리
* 백엔드 리소스에 대한 액세스를 보호
  * SSL등을 통해 기술을 사용하는 보안등을 통해 권한을 확인하여 안전한 연결을 확보

즉, 서버에 요청이 가기 전 먼저 다양한 작업들을 처리하고 처리된 요청을 서버로 전송한다.

### express의 미들웨어
미들웨어 함수를 말한다. 미들웨어 함수는 req객체, res객체, 요청-응답 사이클 도중 그 다음의 미들웨어 함수에 대한 액세스 권한을 갖는 함수.
클라이언트에서 요청이 오고 그 요청을 처리하기 위해 거쳐가는 함수들이다. next 함수를 이용하여 다음 미들웨어로 현재 요청을 넘길 수 있다.
순차적으로 처리되기 때문에 순서가 중요하다.

#### 미들웨어 유형
* 어플리케이션 레벨
  * app.use 및 app.METHOD를 이용하여 app 오브젝트 인스턴스에 바인드 시킨다. 
  * 미들웨어를 어플리케이션 영역에서 지정한 path대로 처리 가능하게 하도록 하며, 특정 경로나 특정 메서드에 대해서만 실행시킬 수도 있다.
* 라우터 레벨
  * Router 인스턴스에 바인드되는 점을 제외하면 어플리케이션 레벨 미들웨어와 같다.
  * 라우터 레벨 미들웨어를 사용하는 이유는 특정 root url을 기점으로 기능을 나눠서 관리할 수 있기 때문. 
* 오류 처리 레벨
  * 에러 핸들링을 위한 미들웨어는 4개의 인자를 사용해서 정의한다.(err, req, res, next)
  * 미들웨어 중간에 오류가 발생하면 에러 처리 미들웨어로 error 객체를 넘겨 에러를 처리할 수 있도록 한다.
* 써드파티 레벨
  * 기능적으로 express app에 미들웨어를 추가하고 싶다면 서드 파티 미들웨어 사용이 권고 된다.



CommonJS방식 - require로 불러오고 위에서부터 작성된 순서대로 불러온다.
ES6방식 - import로 작성된 순서대로가 아니라 먼저 불러와지는 순으로 사용. export로 내보내서 재활용하기 쉽다.

면접 때 전혀 딴 소리를 해버렸다.
카디널리티 - 특정 데이터 집합의 유니크한 값의 갯수. 성별 컬럼을 남녀로 잡았을 때 이 경우 카디널리티는2. 주민등록번호 처럼 모든 값이 유니크 하다면 카디널리티는 레코드의 갯수가 된다.

셀렉티비티(선택도) - 카디널리티에서 계산해 얻는 값. 데이터 집합에서 특정 값을 얼마나 잘 골라낼 수 있는지에 대한 지표. 값이 1이면 모든 값이 유니크 하다는 뜻.
Selectivity = Cardinality / Total Number of Records

선택도는 인덱스를 생성할 컬럼을 고를 때 자주 사용된다. 선택도가 높으면 인덱스가 특정 인덱스를 잘 골라내서 인덱스 효율이 높아진다.

DB에서 인덱스의 선택도를 높이려면 두 개 이상의 컬럼을 조합하면 된다. 조합된 인덱스 키의 카디널리티가 증가하면 결국 선택도가 증가하여 효율이 높아진다. 그러나 인덱스 키를 많이 사용하면 공간 효율이 낮아진다.