### 언어만 배우지 말고 문화를 배워라
다양한 언어를 배우고 사용하며 얻은 교훈은 언어를 배운다는 것은, 문법을 배우는 것 이상으로 문화를 배우는 것이 필요하다.

새로운 언어를 배운다면 기존의 언어를 다른 방식으로 사용할 수 있다는 것에 놀랄 것이며, 식견을 넓히고 다양한 방식으로 문제를 해결하는 방법을 얻을 수 있다.

### 중복을 제거하라
모든 프로그래밍 원칙에서 중복을 제거하는 것이야말로 가장 기본적인 원칙일 것이다. 
* 중복은 낭비이다 - 어플리케이션에 포함된 모든 코드는 미래에 버그를 발생시킬 가능성이 있으며, 반드시 유지보수가 이뤄져야 한다. 
중복은 불필요한 코드를 늘리고 시스템을 복잡하게 만든다. 중복을 피하기 위해서는 시스템 내의 모든 지식이 한 곳에서 명확히 표현되어야 한다.

* 프로세스의 중복은 자동화를 필요로 한다 - 중복성이 있는 프로세스들은 대부분 쉽게 자동화 할 수 있다. 자동화가 가능한 수동 프로세스는 반드시 자동화되고 표준화되어야 한다.

* 로직의 중복은 추상화를 필요로 한다 

* 중복 제거 원칙의 중요성 - 개방/폐쇄 원칙(OCP)오직 중복 제거 원칙이 만족되어야만 달성할 수 있다. 그리고 단일책임원칙(SRP) 또한 마찬가지다.
중복 제거 원칙은 개발자들에게 가장 기본적인 안내를 제공할 뿐 아니라 간단하고 유지보수가 용이하며 품질좋은 어플리케이션 개발에 도움을 준다. 
만약 중복이 필수적인 상황이라면 이러한 중복이 있음을 알 수 있도록 명백하게 표시해 두어야 한다. 

### 그 코드를 건드리면 안된다
대부분의 웹 서비스를 개발하는 환경은 개발자 머신, 개발 서버, 스테이징 서버, 운영 서버로 구성된다. 이 외에도 많은 서버와 서비스들이 있지만 , 개발자는 개발 서버 외에는 접근해선 안된다.

만약 문제가 있다면 지원그룹이 고치거나 그것을 고칠 수 있도록 요청해야 한다. 서버를 분리해서 운영하는 것은 이유가 있으며, 운영 서버는 버그를 고치는 곳이 아니다.

### 상태뿐 아니라 행위까지도 캡슐화 하라
체계 이론(systems theory)에서 봉쇄(containment)는 방대하고 복잡한 시스템을 효율적으로 다루기 위한 유용한 개념의 하나이다. 

봉쇄 또는 캡슐화의 가치는 잘 알려져 있지만 캡슐화를 올바르게 사용하는 것은 어렵고 객체지향 모델링의 장점을 잘 살리지 못하는 경우도 많다.

객체지향에 익숙하지 않은 개발자는 각 클래스에서 독립적으로 수행되었어야 할 모든 로직을 하나의 객체에 포함시키는데, 이렇게 되면 유지보수 거의 불가능하고 쉽게 깨질 수 있다.

이는 캡슐화되지 않았기 때문이다. 캡슐화를 저버리지 말고 유지보수를 위해 프로그래밍 언어의 강점을 활용하라.

### 부동소수점 수는 실수가 아니다
부동소수점 수는 제한된 유효숫자를 가진 유한 수이다. 부동소수점 연산은 가장 가까운 부동소수점 수를 위해 버림을 하고, 실수의 근사값이므로 필연적으로 오차가 발생한다.

그렇기 때문에 알고리즘을 주의 깊게 살펴야 하고 오차를 항상 고려해야 한다.

### 오픈 소스를 통해 잠자고 있는 열망을 이뤄라
오픈 소스는 개발자에게 많은 기회를 제공한다. 흥미 있어하는 문제를 다른 사람이 어떤 방법으로 해결하는지 볼 수 있고, 소스코드와 아이디어를 프로젝트에 남길 수 있다.
또, 열정을 가진 뛰어난 사람을 만날 수 있고 기술경력을 쌓을 수도 있다. 

오픈소스 프로젝트에 참여하는 것은 쉽다. 소스코드 관리도구, 프로그래밍 언어 등 필요로하는 도구와 문서는 충분히 있다. 
진정으로 원하는 프로젝트를 찾아보고 그 프로젝트에서 사용하는 도구들에 대해 배우라. 프로젝트 소스코드를 분석하면서 많은 것을 배울 수 있고, 
테스트 코드를 작성하는 것을 통해 그 어떤 것보다 빠르게 소프트웨어에 대해 배울 수 있다.

훌륭한 테스트코드를 작성해보고, 버그를 찾고, 그것을 고치는 법을 제안하고, 친구를 만들고, 좋아하는 소프트웨어를 위해 일한다면 개발에 대한 열망을 이룰 수 있을 것이다.

### API 설계의 황금률
많은 사용자들을 위한 API 설계는 어렵다. 미래에 어떻게 바뀔지, 변경사항이 클라이언트 코드를 손상시킬지 여부를 고려해야 한다.

API 설계를 할 때 실제 유스케이스 처럼 생각해야만 점차 나아질 것이고, 그것은 자신의 코드를 테스트하는 것보다 복잡하다. 개발하는 API를 위한 테스트로는 부족하고 API를 사용하는 코드를 위한 단위테스트를 작성해야 한다.

테스트 이슈에 대해 알고 있는 것이 중요한데, 이는 직접 경험해보아야 한다. 한 번 그렇게 하면 다른 설계의 도전에도 응할 수 있을 것이다.

### 버그 트래커를 이용하는 방법
버그를 피할 수는 없다. 프로젝트를 잘 이끌어 나가는 데 있어 버그 리포트를 훌륭히 작성하는 방법을 아는 것은 버그를 찾는 것 만큼이나 핵심 기술이다.

훌륭한 버그 리포트는 세 가지를 전달해야 하고, 버그에 대해 보고된 정보의 양과 품질은 많은 것을 말한다.
* 버그를 어떻게 재현할 수 있는지를 가능한 상세하게, 얼마나 자주 발생하는지

* 생각하기에 어떤 결과가 나와야 했는지

* 실제로는 어떤 결과가 나왔는지. 아니면 줄 수 있는 최대한의 정보가 무엇인지

팀의 모든 사람이 작업할 예정인 버그를 어떻게 찾을 수 있는지 알게 하고, 어떻게 사용해야 하는지 알게 하라.

### 프로세스간 통신은 응용프로그램 반응 시간에 영향을 미친다
소프트웨어의 유용성이라는 측면에서 반응 시간은 매우 중요하다. 성능과 관련된 문헌 대부분에서는 여전히 데이터 구조와 알고리즘에 초점을 맞추지만 다계층 기업용 응용프로그램에서는 데이터 구조와 알고리즘의 영향을 거의 받지 않는다.

응용프로그램에서 성능이 문제가 될 때, 반응 시간은 원격 프로세스간 통신의 수에 좌우된다. 원격 호출 요청이 많아질수록 응답 시간도 크게 늘어날 것이다. 원격 프로세스간 통신을 줄이는 방법에는 잘 알려진 몇가지가 있다.

* 인색함의 법칙(the principle of parsimony) - 프로세스 간의 인터페이스를 최적화 해 목적에 맞는 필요한 데이터만을 교환 할 수 있도록 만드는 것.

* 프로세스간 통신의 병렬화 - 동시에 진행될 수 있는 것들을 병렬화 하면 응답 시간이 가장 늦은 통신에 좌우된다.

* 이전의 프로세스간 통신 내용을 캐시하는 것 - 향후 프로세스간 통신을 하는 대신 로컬에서 캐시된 내용을 가져올 수 있다.

각 요청당 동작하는 프로세스간 통신의 수를 줄이는 것이 데이터 구조를 변경하거나 알고리즘을 개선하는 것보다 훨씬 더 좋은 성과를 올릴 수 있다.

### 두 개 이상의 프로그래밍 언어를 습득하라
모든 프로그래머는 하나의 프로그래밍 언어로 시작한다. 그 언어는 프로그래머가 소프트웨어어 대해 생각하는 방법에 지배적인 영향을 미치고, 하나의 언어만 아는 프로그래머는 그 언어에 의해 사고가 제약된다.

다른 언어를 배울 때 어려움을 겪을 것이며 처음 배운 언어와 전산 모델이 다른 언어라면 더욱 어려울 것이다. 프로그래밍 언어들의 이용에서 상호 교류는 아주 큰 효과가 있다. 

모든 프로그래머는 두 개 이상, 가급적이면 친근하지 않은 패러다임을 배워야 한다. 어떤 언어의 문제 해결법이 다른 언어에서는 가능하지 않을 수 있고, 다른 패러다임의 문제 해결법을 아는 것은 사용하는 언어의 세련됨을 증가시키는 방법이다.

한 언어에 대해 일하기 충분한 지식을 얻기까지 몇 개월은 걸린다. 가장 중요한 요소는 문법이나 전산 모델이 아니라 유용한 이디엄(Idiom - 패턴보다 더 작은 범위의 문제를 다루며, 일반적으로 개발 언어에 종속적인 패턴)들이다.

### 예측하는 것을 배워라
정확히 예측하려면 예측에 대한 기술을 배우는 것이 중요하다. 예측이란 무엇이고, 그것이 어떻게 사용되는지 배워야 한다.

* 예측(estimate) - 어떤 값, 숫자, 품질 등에 대한 대략적인 계산이나 판단. 예측은 객관적인 자료나 과거의 경험에 의해 도출된다. 또 예측은 대략적이며 정확할 수 없다.

* 목표(target) - 요구되는 비즈니스 목표에 대한 선언.

* 커밋먼트(commitment) - 특정한 목표가 특정한 날짜까지 어떤 정도의 품질 수준으로 이루어져야 한다는 것을 기술한 것.

예측, 목표, 커밋먼트는 상호 독립적인 개념이지만, 목표와 커밋먼트는 믿을만한 예측에 근거를 두어야 한다. 소프트웨어 예측의 궁극적인 목적은 프로젝트의 결과를 예측하는 것이 아니라, 프로젝트의 목표들이 달성할 수 있을 만큼 현실성이 있는지 판단하는 것이다.

### 정확한 사용이 쉽고, 잘못된 사용이 어려운 인터페이스를 만들어라
좋은 인터페이스의 특징은 다음과 같다.

* 정확한 사용이 쉽다 - 잘 설계된 인터페이스는 사람들이 정확하게 사용하도록 한다. 잘 작성된 GUI에서는 정확한 아이콘을 누를 것이고, 잘 작성된 API에서는 파라미터에 정확한 값을 전달할 것이다.
왜냐하면 그것이 가장 자연스럽기 때문이다. 

* 잘못된 사용이 어렵다 - 좋은 인터페이스는 사용하는 사람들이 실수할 수 있는 부분을 사전에 예측해 실수하지 않도록 만든다. GUI에서는 상황에 맞지 않는 버튼을 비활성화하고, API에서는 파라미터를 순서에 관계없이 받을 수 있도록 할 것이다.

정확한 사용이 쉬운 인터페이스를 설계하는 좋은 방법은 개발하기 전에 시험해보는 것이다. 이 인터페이스가 어떻게 동작하기를 원하는지, 어떤 정보를 전달하기 원하는지, 사용자 관점에서 개발한다면 더 쉽게 이러한 인터페이스를 만들 수 있다.

잘못 사용하기 어려운 인터페이스를 만들려면 사용자의 실수를 예상하고 그것을 방지하는 방법을 찾고, 인터페이스가 잘못 사용되고 있는지 관찰하면서 사용자가 잘못하지 않도록 인터페이스를 변경해야 한다.

인터페이스는 설계자가 아니라 사용자를 위해 존재한다.

### 보이지 않는 것을 더 잘 보이게 하라
소프트웨어나 소프트웨어를 개발하는 과정의 대부분은 눈에 보이지 않는다. 소스코드는 본질적으로 실체가 없으며, 동작하는 어플리케이션은 실체가 있어도 그 어플리케이션이 소스코드로 만들어졌다는 것을 드러내지는 않는다.

프로젝트가 정상적인 개발일정에 맞춰 진행되고 있었는데 1주일 후에 6개월 지연되어야 한다고 알려지면 프로젝트에 문제가 있는 것이다. 가장 큰 문제는 6개월 지연이 아니라 지연을 감출 정도로 강력한 비가시성이다. 진척상황의 가시성이 부족하다는 것은 진척상황이 없는 것과 같다.

단위 테스트를 작성해보면 그 코드가 단위 테스트를 수행하기 쉬운지 확인할 수 있다. 이는 코드가 낮은 결합도와 높은 응집성 같은 품질을 갖추었는지 혹은 갖추지 못했는지 드러낸다.

단위 테스트를 실행해보면 코드의 동작에 대해 확인 할 수 있다. 이는 코드가 견고함이나 정확성 같은 실행 단계에서의 품질을 갖추었는지 혹은 갖추지 못했는지 드러낸다.

눈으로 확인할 수 있는 많은 결과를 가지고 진척사항을 가시적이고 구체적으로 파악하는 것이 소프트웨어를 개발하는 가장 좋은 방법이다. 가시적인 것은 허상이 아니라 실질적이어야 하고, 계획적이어야 하며, 임시적인 것이 아니라 반복적인 것이어야 한다.
