# 자신을 제외한 배열의 곱
input: [1,2,3,4]

output: [24, 12, 8, 6]

주의: 나눗셈을 하지 않고 O(n)에 풀이하라

### 왼쪽 곱셈 결과에 오른쪽 값을 차례대로 곱셈

미리 전체 곱셈 값을 구해 놓고 각 항목 별로 자기 자신을 나눠서 풀이하는 방법은 안된다는 뜻. 

```python
def product_except_self(self, nums:list[int]) -> list[int]:
    out = []
    p = 1
    # 왼쪽 곱셈
    for i in range(0, len(nums)):
        out.append(p)
        p = p * nums[i]
    p = 1
    """
    1,2,3,4
    0: out[0] = 1, p = 1 * 1 -> 1
    1: out[1] = 1, p = 1 * 2 -> 2
    2: out[2] = 2, p = 2 * 3 -> 6
    3: out[3] = 6, p = 6 * 4 -> 24, p = 1 초기화
    [1, 1, 2, 6]
    """
    # 왼쪽 곱셈 결과에 오른쪽 값을 차례대로 곱셈
    for i in range(len(nums) -1, 0 - 1, -1):
        out[i] = out[i] * p
        p = p * nums[i]
    """
    인덱스가 역으로(오른쪽에서 왼쪽으로) 생성됨
    3: out[i] * p = (6 * 1 -> out[3]은 6), p * nums[i] = (1 * 4 -> p는 4)
    2: out[i] * p = (2 * 4 -> out[2]은 8), p * nums[i] = (4 * 3 -> p는 12)
    1: out[i] * p = (1 * 12 -> out[1]은 12), p * nums[i] = (12 * 2 -> p는 24)
    0: out[i] * p = (1 * 24 -> out[0]은 24), p * nums[i] = (24 * 1 -> p는 24)
    [24, 12, 8, 6]
    """
    return out
```
* 왼쪽 곱셈
  * 변수 i가 이동하면서 해당 인덱스의 값을 곱해 나간 다음, 오른쪽에서 곱해서 넣는다. 
  * 만약 별도의 리스트 변수를 만들고 그 변수에 우측 곱셈 결과를 넣으면 공간복잡도는 O(n)이 된다.
  * 그러나 기존 out 변수를 재활용 한다면 공간 복잡도 O(1)에 풀이가 가능하다.
* 왼쪽 곱셈 결과에 오른쪽 값을 차례대로 곱셈
  * for문의 range(x, y, z)에서 세번째 파라미터인 z는 증분을 지정하는 파라미터. -1 이므로 여기서는 1씩 줄어든다.
  * p가 차례대로 커지면서 4, 12, 24가 되고 최종적으로 이 값이 왼쪽 곱셈 결과에 곱해져 out 변수에는 정답인 [24, 12, 8, 6]이 담긴다.


