# 삽입 정렬
```python
def insert_sort(x):                     #          시작시
    for i in range(1, len(x)):          #          for 1 in range(1, 10)  
        j = i - 1                       #              j = 0
        key = x[i]                      #              key = x[1]
        while x[j] > key and j >= 0:    # 1            while x[0] > x[1] and 0 >= 0           
            x[j + 1] = x[j]             # 2                x[1] = x[0]
            j = j - 1                   #                  j = -1 
        x[j+1] = key                    # 3            x[0] = x[1]
        print(x)
    return x
num_arr = [5, 3, 7, 8, 6, 9, 2, 1, 4, 0]
insert_sort(num_arr)
```
* 1: x[ j ]는 while문을 돌 때 마다 -1 되므로 점점 작은 쪽으로 이동한다.
* 2: while문이 돌 때마다 x[ j + 1 ]에 있는 값이 x[ j ]로 바뀐다. 즉, 값이 뒤로 1씩 밀린다.
* 3: j >=0일 때 while문을 빠져나오면 x[ j ] 보다 x[ i ]가 크다는 뜻이므로 거기가 삽입될 장소다. 따라서 x[ j + 1 ]위치에 삽입한다.
```python
#input
[5, 3, 7, 8, 6, 9, 2, 1, 4, 0] # 5 > 3 = True -> 3을 맞는 위치에 삽입한다
#연산
[3, 5, 7, 8, 6, 9, 2, 1, 4, 0] # 5 > 7 = False
[3, 5, 7, 8, 6, 9, 2, 1, 4, 0] # 7 > 8 = False
[3, 5, 7, 8, 6, 9, 2, 1, 4, 0] # 8 > 6 = True -> 6을 맞는 위치에 삽입한다
[3, 5, 6, 7, 8, 9, 2, 1, 4, 0] # 8 > 9 = False 
[3, 5, 6, 7, 8, 9, 2, 1, 4, 0] # 9 > 2 = True -> 2을 맞는 위치에 삽입한다
[2, 3, 5, 6, 7, 8, 9, 1, 4, 0] # 9 > 1 = True -> 1을 맞는 위치에 삽입한다
[1, 2, 3, 5, 6, 7, 8, 9, 4, 0] # 9 > 4 = True -> 4을 맞는 위치에 삽입한다
[1, 2, 3, 4, 5, 6, 7, 8, 9, 0] # 9 > 0 = True -> 0을 맞는 위치에 삽입한다
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] # 정렬 완료
```
* 특정 값에 대해 그 값이 맞는 위치를 찾고 나머지는 밀어낸다.
* 시간 복잡도 O(n^2)중 가장 빠른 형태이기에, 작은 단위에서는 삽입 정렬을 쓰기도 한다.
