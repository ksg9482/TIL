# node.js의 작동
## I/O 시스템
### I/O는 느리다
I/O는 컴퓨터의 기본적인 동작들 중 가장 느리다. 
RAM에 접근하는데는 나노초인 반면 디스크와 네트워크에 접근하는데는 밀리초가 걸리고, 인간이라는 요소를 고려하면 I/O는 기술적인 측면 말고도 더욱 느려질 수 있다.

### 블로킹 I/O
전통적인 블로킹 I/O 프로그래밍에서는 I/O를 요청하는 함수의 작동이 끝날 때까지 스레드의 실행을 차단한다.   
여러 연결이 들어와도 블로킹 I/O는 소켓의 각각의 I/O 작업이 다른 연결의 처리를 차단한다.   

전통적인 해결법은 개별 프로세스 / 스레드를 두는 것이지만 이 방법은 시스템 리소스 측면에서 비용이 저렴하지 않고, 스레드가 블로킹되는 문제는 여전하다.   
스레드 블로킹은 메모리와 cpu 사이클을 낭비하게 만든다.

### 논블로킹 I/O
가장 기본적인 패턴은 실제 데이터가 반환될 때까지 루프내에서 리소스를 적극적으로 폴링(poll)하는 것이다. 이것을 바쁜 대기(busy-waiting)이라 한다.   
하지만 이런 방법은 사용할 수 없는 리소스를 반복하는 데에 cpu를 낭비하기 때문에 비효율 적이다.
___
## 이벤트 디멀티플렉싱
동기 이벤트 디멀티플렉서 또는 이벤트 통지 인터페이스라고 한다. 
멀티플렉싱이란 여러 신호를 하나로 합성하여 제한된 수용범위 내에서 매개체를 통해 쉽게 전달하는 방법을 나타내고, 반대로 디멀티플렉싱은 신호가 다시 원래의 구성요소로 분할되는 작업이다.   
이 두 용어는 서로 다른 것들을 합성하고 다시 분할하는 일반적인 작업을 설명하는데 사용된다.

동기 이벤트 디멀티플렉서는 여러 리소스를 관찰하고 이 리소스중 읽기 또는 쓰기 연산의 실행이 완료되었을 때 새로운 이벤트를 반환한다.

* 각 리소스가 데이터구조(list)에 추가되고, 각 리소스는 특정 연산과 연결된다.
* 디멀티플렉서가 관찰된 리소스 그룹과 함께 설정된다. 동기식으로 관찰되는 리소스 중에서 읽을 준비가 된 리소스가 있을때까지 블로킹되고, 준비된 리소스가 생기면 이벤트 디멀티플렉서는 처리를 위한 새로운 이벤트 세트를 반환한다.
* 이벤트 디멀티플렉서에서 반환된 이벤트가 처리된다. 이 시점에서 각 이벤트와 관련된 리소스는 읽을 준비 및 차단되지 않는 것이 보장된다.
* 모든 이벤트가 처리되고 나면, 이 흐름은 다시 이벤트 디멀티플렉서가 처리 가능한 이벤트를 반환할 때까지 블로킹된다.
* 이를 이벤트루프(event loop)라고 한다.

이 패턴을 이용하면 여러 I/O를 단일 스레드 내에서 다룰 수 있다. 작업은 여러 스레드에 분산되는 대신 시간에 따라 분산된다.
하나의 스레드만 가지는 것은 일반적으로 경쟁상태의 발생과 다중 스레드의 동기화 문제 없이 더 간단한 동시성 전략을 사용할 수 있게 해준다.

### 리액터(reactor) 패턴
리액터 패턴의 주된 아이디어는 각 I/O 작업에 연관된 핸들러를 갖는다는 것이고 node.js의 핸들러는 콜백 함수에 해당한다.   
이 핸들러는 이벤트가 생성되고 이벤트 루프에 의해 처리되는 즉시 호출된다.   
* 어플리케이션은 이벤트 디멀티플렉서에 요청을 전달하여 새로운 I/O 작업을 생성하고, 작업이 완료되었을때 호출될 핸들러를 명시한다.(이 요청을 전달하는 것은 논 블로킹 호출이며 제어권은 즉시 어플리케이션으로 반환된다.)
* I/O 작업이 완료되면 이벤트 디멀티플렉서는 대응하는 이벤트 작업을 이벤트 큐에 넣는다.
* 이 시점에서 이벤트 루프가 이벤트 큐의 항목들을 순환한다.
* 각 이벤트와 관련된 핸들러가 호출되고, 핸들러 실행이 완료되면 제어권을 이벤트 루프에 되돌린다. 
  * 핸들러 실행중에도 다른 비동기 작업을 요청하여 이벤트 디멀티플렉서에 새로운 항목을 추가할 수 있다.
* 이벤트 큐의 모든 항목이 처리되고 나면, 이벤트 루프는 이벤트 디멀티플렉서에서 블로킹되며 처리 가능한 새 이벤트가 있을 때 이 과정이 다시 트리거 된다.

정리하자면, 리액터 패턴은 관찰대상 리소스에서 새 이벤트를 사용할 수 있을 때까지 블로킹하여 I/O를 처리하고 각 이벤트를 관련된 핸들러에 전달함으로써 반응한다.

### node.js의 I/O 엔진
각 운영체제는 이벤트 디멀티플렉서를 위한 각각의 자체 인터페이스를 가지고 있고, 또 리소스 유형에 따라 다르게 동작한다.   
서로 다른 운영체제 간의 불일치성은 이벤트 디멀티플렉서를 위해 보다 높은 추상화를 필요로 했고, node.js 코어 팀은 논 블로킹 동작을 추상화하기 위해 Libuv라고 불리는 C라이브러리를 만들었다.

Libuv는 기본 시스템 호출을 추상화하는 것 외에도 이벤트 루프 생성, 이벤트 큐 관리, 비동기 I/O 실행 및 다른 유형의 작업을 큐에 담기 등 여러 기능을 수행하기 위한 API를 제공한다.

### node.js의 구성
* 리액터 패턴으로 동작하는 Libuv 라이브러리
* Libuv와 다른 저수준 기능들을 래핑하고 표출시키는 바인딩 세트
* V8엔진. 크롬 브라우저를 위해 구글이 개발한 javascript엔진으로 node.js가 빠르고 효율적인 이유중 하나이다.
* 고수준 node.js API를 구현하고 있는 코어 javascript 라이브러리
___

## node.js 에서의 javascript
node.js에서 실행되는 javascript와 브라우저에서 실행되는 javascript는 다소 다르다.
* node.js는 DOM, window, document가 없다.
* 브라우저에서는 불가능하지만 node.js는 운영체제에서 기본적으로 제공하는 서비스들에 접근이 가능하다.

### node.js 에서 javascript를 실행할 때의 명심할 점
#### 최신 javascript를 실행시킬 것
브라우저를 통해 javascript를 실행시킨 다는 것은 javascript가 여러 브라우저의 특징에 영향을 받음을 의미한다. 그리고 같은 브라우저라도 버전이 다르면 마찬가지로 영향을 받는다.
그러나 node.js를 통해 javascript를 실행하면 javascript는 이미 잘 알려진 시스템과, node.js 런타임 상에서 실행된다.

node.js가 가장 최신의 V8엔진을 가지고 있다는 것은 최신 ECMAScript사양의 대부분을 사용할 수 있다는 뜻이다.

만약 서드파티에서 사용되기 위한 라이브러리를 개발한다면, 라이브러리가 다양한 node.js 버전에서 사용된다는 뜻이므로 그에 대해 명시하는 것이 좋다.

#### 모듈 시스템
본래의 node.js 모듈시스템은 CommonJS라고 불렸고, 임포트 하기위해 require 키워드를 사용한다.   
오늘날에는 ES모듈 문법(import, export)을 가지고 있다.

#### 운영체제 기능에 대한 접근
node.js는 브라우저 영역 안에서 실행되는 것이 아니기 때문에 운영체제가 제공하는 서비스들에 접근할 수 있다.   
운영체제 레벨의 허가가 필요하지만, fs모듈의 도움으로 파일시스템에 있는 파일에 접근하거나, net 혹은 dgram 모듈로 어플리케이션이 저수준의 TCP, UDP 소켓을 사용하게 할 수 있다.

또 V8엔진을 이용하거나 HTTP(S)서버 생성, crypto 모듈을 통해 OpenSSL의 해시 알고리즘을 사용 할 수 있다.

#### 네이티브 코드 실행
C/C++로 만들어진 컴포넌트를 사용 할 수 있고, 사물인터넷이나 로보틱스에도 사용될 수 있다.   
node.js를 포함한 대부분의 javascript 가상머신은 javascript 이외의 언어(C등)를 이해하기 위해, 다른 언어를 웹어셈블리(WASM)라는 저수준 명령 형식을 통해 가상머신이 이해할 수 있도록 컴파일 한다.

___
## 요약 
* node.js는 최소한의 코어를 가지고 있으며, 최소한의 필요 기능만을 노출한다.
* node.js는 리액터 패턴을 통해 이벤트루프(Libuv 라이브러리)를 구현하여 I/O를 처리한다.
* node.js는 운영체제가 제공하는 기능들에 접근하여 이용할 수 있다.
* node.js는 네이티브 코드를 실행할 수 있다.
