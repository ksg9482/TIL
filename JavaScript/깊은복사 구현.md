### 깊은 복사
자바스크립트의 자료구조는 크게 두 종류다. 문자열, 숫자와 같은 원시 타입. 그리고 객체, 배열과 같은 참조 타입. 물론 배열은 따지고 보면 배열의 역할을 원활하게 수행하도록 최적화된 객체이다.

그렇기 때문에 복사에 대해서도 특이한 점이 생겨난다. 바로 값을 복사하느냐, 아니면 그 값이 담긴 메모리 주소를 복사하느냐 하는 점이다. 간단하게 보면 복사를 했을 때 그 값이 아니라 메모리 주소를 복사하는 것이 얕은 복사이고 메모리 주소가 가리키는 값을 복사하는 것이 깊은 복사이다.
### 일반적인 복사법
원시 타입은 단순 할당으로 충분하다. 변수가 가리키는 것이 주소가 아니라 값이기 때문이다. 하지만 참조 타입을 복사하려면 이야기가 복잡해진다. 일반적으로 객체를 복사하면 값이 아니라 주소가 복사된다. 서로 다른 두 변수라고 해도 같은 주소를 가리키고 있으면 같은 내용일 뿐이다.

참조 타입을 복사할 때는 보통 배열인 경우 slice(), spread문법을 이용할 것이다. 객체인 경우에는 spread문법을 이용할 것이고. 하지만 이런 방법은 1차원만 깊은 복사한다. 객체 내부에 또 다른 객체가 있으면 2차원 이상의 객체는 여전히 얕은 복사인 것이다.   
### n차원 참조 타입을 복사하려면?
2차원 이상의 참조 타입을 깊은 복사하려면 결국 모든 값을 하나하나 다룰 수 밖에 없다. for loop를 돌리거나 재귀를 이용해야 한다. 실제로 자주 쓰이는 Lodash의 cloneDeep()도 인수로 받은 객체를 재귀적으로 깊은 복사한다.

대략 아래의 코드와 비슷한 느낌이다. 타입스크립트로 작성해서 그렇지 중요한 것은 객체는 객체대로, 배열은 배열대로 반복해서 그 내부까지 깊은 복사 하는 것이다.
```typescript
deepCopy(obj: any) {
        if (obj instanceof Object) {
            let result = new obj.constructor();
            Object.keys(obj).forEach(k => {
                result[k] = deepCopy(obj[k]);
            })
            return result;
        }
        else if (obj instanceof Array) {
            obj.map(element => deepCopy(element));
        }
        else return obj;
    }
```
