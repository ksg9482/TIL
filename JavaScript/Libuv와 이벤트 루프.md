# Libuv와 이벤트 루프

## LIbuv
순수 자바스크립트는 동기적으로 작동하지만 비동기적으로 작동시킬 수 있는 이유는 자바스크립트 엔진 바깥을 감싸고 있는 호스팅 환경 덕분이다.
Node.js는 내부에 가지고 있는 libuv 라이브러리를 통해 이벤트루프를 구현했다. 이벤트루프는 크게 여섯 단계의 페이즈를 순환하고 있는데, 각 페이즈는 libuv를 통해 커널 혹은 쓰레드 풀에 인계했던 콜백 작업을 실행한다.
모든 비동기 작업은 libuv를 통해 스케줄링 되었다가 이벤트 루프의 순환 주기에 따라 호출된다.

그렇다면 libuv는 어떻게 비동기 작업을 실시하는가? libuv는 사실 운영체제의 커널을 추상화한 wrapping 라이브러리로, 커널이 어떤 비동기 API를 지원하는지 알고 있다.
libuv에 비동기 작업을 요청하면 libuv는 이 작업을 커널이 지원하는지 확인하고, 지원한다면 커널에 요청해서 요청에 대한 응답을 전달한다.
만약 지원하지 않으면 자기만의 워커 스레드가 담긴 스레드풀을 사용해 처리한다.

libuv는 기본적으로 4개의 스레드를 가지는 스레드풀을 생성하지만, 환경변수를 통해 스레드를 128개까지 늘릴 수 있다.

* Node.js는 libuv에 비동기 작업을 요청한다.
* libuv는 커널이 해당 비동기 작업을 지원하는지 확인한다.
  * 지원한다면, 커널에게 비동기 작업을 요청하고 그 응답을 Node.js에 반환한다.
  * 지원하지 않는다면, 자기의 스레드 풀을 사용해 비동기 작업을 처리하고 Node.js에 반환한다.
    * 워커 스레드는 비동기 작업을 받아서 동기적으로 처리한다.

**Node.js** -> 비동기 요청 -> **libuv** -> 비동기 작업 전달 -> **스레드 풀** -> 동기 요청 -> **파일 시스템**   
**Node.js** <- 비동기 응답 <- **libuv** <- 처리한 응답 전달 <- **스레드 풀** <- 동기 응답 <- **파일 시스템**

## 이벤트 루프와 페이즈

이벤트 루프의 페이즈는 다음과 같다.

* Timer Phase
* Pending Callbacks Phase
* Idle, Prepare Phase
* poll Phase
* Check Phase
* Close Callbacks Phase
  * 다시 Timer Phase로 넘어가기 전에 이벤트루프가 살아 있나(큐에 남은 작업이 있는지) 확인한다.

또 이 6개의 페이즈와 별개로 nextTickQueue와 microTaskQueue도 있는데, 이것들은 이벤트 루프의 관리를 도와준다.

페이즈는 Timer Phase부터 Close Callbacks Phase를 지나 다시 Timer Phase로 넘어가는 순서를 따른다. 한 페이즈에서 다름 페이즈로 넘어가는 것을 틱(Tick)이라고 부른다.
각 페이즈는 자신만의 큐를 하나씩 가지고 있고, 이 큐에는 이벤트 루프가 실행해야 하는 작업들이 순서대로 담겨 있다.

Node.js가 페이즈에 진입하면 이 큐에서 자바스크립트 코드를 하나씩 꺼내 실행하는데, 만약 큐에 있는 작업들을 다 실행하거나 시스템 실행 한도에 이르면 Node.js는 다음 페이즈로 넘어간다.

이때 주의해야 할 것은, 이벤트 루프가 Node.js의 비동기 실행을 도와주는 것과는 별개로 싱글스레드 이므로 한번에 하나의 페이즈에만 진입해 작업을 처리 할 수 있다는 점이다. 복수의 페이즈를 동시에 처리하거나, 하나의 페이즈에서 여러 작업을 동시에 처리하는 것은 불가능하다.

그렇다면 이벤트 루프는 한개의 페이즈에 영원히 갇힐 수 있는가? 결론부터 말하면 불가능하다.

큐에서 작업을 꺼내 처리하다 보면 새로운 작업이 들어와서 그것도 처리해야 하거나, 이전 페이즈에서 실행했던 작업의 콜백이 돌아와서 다음 페이즈로 이동하지 못할 수 있다. 그러나 시스템 실행 한도의 영향을 받기에 한 페이즈에 영원히 갇히지는 않는다.
 * nextTickQueue는 시스템 실행 한도의 영향을 받지 않기 때문에 영원히 갖힐 수 있으니 주의 할 것.


## Node.js의 실행과 이벤트 루프의 흐름
각 페이즈는 자신이 관심있는 작업들만 관리한다. 예를 들어 Timer Phase는 타이머에 관한 비동기 작업들만 관리한다.

어떤 자바스크립트 코드를 실행하면 Node.js는 우선 이벤트 루프를 만든다. 그리고 이벤트 루프 바깥에서 코드를 실행하고, 그리고 나서야 이벤트 루프를 확인한다.
이벤트 루프에 남은 작업이 있다면 Node.js는 이벤트 루프에 진입해 반복해서 작업을 실행하고, 남은 작업이 없으면 process.on('exit', callback)을 실행하고 이벤트 루프를 종료한다. 

### Timer Phase
Timer Phase는 setTimeout, setInterval 등이 만들어내는 타이머들을 관리한다.

큐에 직접 담지는 않지만, 콜백을 언제 실행할지에 대한 정보가 담긴 타이머를 Timer Phase가 관리하는 min-heap에 넣는다. 그리고 타이머를 실행할 시간이 되면 그 타이머가 가리키는 콜백을 호출한다.
 * min-heap은 최솟값을 찾는데 최적화 되어 있기 때문에 실행 할 수 있는 가장 빠른 타이머를 쉽게 찾을 수 있다.
 * Timer Phase에서는 타이머를 관리만 하는 것이 아니라, 타이머를 검사하고 실행도 한다.

Node.js는 Timer Phase에서만 타이머를 검사하기 때문에 타이머는 Node.js가 Timer Phase에 진입하지 않으면 실행되지 않는다. 
setTimeout(fn, 1)을 하더라도 Node.js가 이벤트 루프를 만들고 Timer Phase 진입에 1ms도 걸리지 않았다면 setTimeout은 실행 될 수 없다. 타이머가 지나지 않았으니 다음 페이즈로 넘어가 버리는 것이다. 
만약, setTimeout(fn, 0)을 해도 마찬가지다. setTimeout 내부적으로는 입력되는 딜레이가 1ms보다 작으면 1ms로 설정하기 때문에 setTimeout(fn, 1)와 다를게 없어진다.

그리고 시스템 실행 한도의 영향도 받기 때문에 실행하지 못하고 다음 페이즈로 넘어갈 수도 있다.
따라서 타이머는 정확히 그 타이밍에 함수를 실행하는 것이 아니라 **딜레이 시간 이후**에 실행됨을 보장하는 것이다. 그래서 타이머는 매 실행마다 결과가 달라질 수도 있다.



### Pending Callback Phase
Pending Callback Phase는 이전 이벤트 루프에서 수행되지 못했던 I/O 콜백들을 관리한다.

시스템 실행 한도에 의해 이벤트 루프가 큐에 쌓인 작업들을 모두 실행하지 못하고 다음 페이즈로 넘어갈 경우, 처리하지 못한 작업들을 다음 이벤트 루프의 Pending Callback Phase에 옮겨 실행한다.
 * 에러 핸들러 콜백 또한 여기로 들어오게 된다.
 * 이 페이즈에서도 시스템 실행 한도를 넘기 전까지만 콜백을 처리한다.

### Idle, Prepare Phase
이 페이즈들은 Node.js의 내부적인 관리를 위한 페이즈로 자바스크립트를 실행하지 않고, 코드의 직접적인 실행에도 영향을 미치지 않는다.

### Poll Phase
새로운 I/O 이벤트를 관리하며, watcher_queue의 콜백들을 실행한다. watcher_queue에는 I/O에 대한 거의 모든 콜백이 담긴다.
 * setTimeout, setImmediate, close 등은 제외한다.
 * 데이터 베이스에 쿼리를 보내고 응답이 오면 실행하는 콜백
 * HTTP 요청을 보낸 후 응답이 오면 실행하는 콜백
 * 파일을 비동기로 읽은 후 실행되는 콜백 등

주의점은, 타이머와 달리 큐에 담긴 순서대로 I/O 작업이 완료된다는 보장이 없다는 것이다. 만약 데이터베이스에 A, B 쿼리를 순서대로 보냈어도 응답은 B, A순으로 올 수도 있다.
A를 실행하기 위해 먼저 완료된 B 콜백 처리를 미룰 수는 없기에, 순서와 상관 없이 완료된 콜백을 먼저 처리하게 된다.
또, 이벤트 루프 혼자서 I/O 이벤트가 언제 완료되었는지 알 수 없다. 이런 문제를 해결하기 위해 Poll Phase는 단순한 콜백 queue를 사용하지 않는다.

이벤트 루프가 n개의 열린 소켓을 가지고, n개의 완료되지 않은 요청이 있다고 하자. 이 n개의 소켓과 메타데이터를 가진 watcher를 관리하는 queue가 watcher_queue다.
각 watcher는 FD(File Descriptor)를 가지고 있는데, 이 FD는 네트워크 소켓, 파일 등을 가리킨다. 운영체제가 FD가 준비되었다 알리면 이벤트 루프는 watcher를 찾을 수 있고, watcher가 맡은 콜백을 실행 할 수 있다.

Poll Phase도 시스템 실행 한도의 영향을 받기에 콜백을 다 처리하지 못할 수 있다.

#### Poll Phase blocking 
Node.js가 Poll Phase에 진입했을 때 대기중인 I/O 요청이 없거나 아직 응답이 오지 않는다면, Poll Phase는 Node.js가 다음 페이즈로 이동해 다시 Poll Phase로 올 때 실행할 수 있는 작업이 있는지 고려한다. 이것이 다른 페이즈들과 다른 점이다. 
Poll Phase에 진입해서 콜백들을 실행해 watcher_queue가 비거나 처음부터 비어있었다면 이벤트 루프는 Poll Phase에서 잠시 대기할 수 있다. 대기 시간은 여러 조건에 의해 결정된다.

### Check Phase
이 페이즈는 오직 setImmediate의 콜백을 위한 페이즈이며, setImmediate가 호출되면 Check Phase의 큐에 담겨 Node.js가 페이즈에 진입하면 실행된다.

process.nextTick은 같은 페이즈에서 호출한 즉시 실행되는데 반해, setImmediate는 다음 틱에서, 정확히는 Node.js가 틱을 거쳐 Check Phase에 진입하면 실행된다.
따라서 동작만 본다면 이름과 달리 process.nextTick은 즉시 실행, setImmediate는 다음 틱에 실행된다.

### Close Callbacks Phase
socket.on('close', () => {});과 같은 close 이벤트 타입의 핸들러를 처리한다. 정확하게는 uv_close()를 부르면서 종료된 핸들러의 콜백들을 처리하는 페이즈로, 시스템 실행 한도를 초과하기 전까지 closing_handles에 담긴 작업을 순서대로 실행한다.

### nextTickQueue와 microTaskQueue
이 두가지는 이벤트 루프의 일부가 아니다. libuv에 포함되어 있지 않고, Node.js에 구현되어 있기 때문에 이벤트 루프의 페이즈와 상관없이 동작한다.

* nextTickQueue는 rocess.nextTick()의 콜백을 관리한다.
* microTaskQueue는 Resolve된 프라미스 콜백을 가지고 있다.
* nextTickQueue는 microTaskQueue보다 높은 우선순위를 가지기 때문에 먼저 실행된다.
* nextTickQueue와 microTaskQueue는 현재 페이즈와 상관없이 수행하는 작업이 끝나면 즉시 실행한다.
* nextTickQueue와 microTaskQueue는 시스템 실행 한도에 영향을 받지 않기 때문에 queue가 비워질 때까지 콜백들을 실행한다.

### Node 버전에 따른 실행방식의 변화
nextTickQueue와 microTaskQueue, 페이즈 간의 동작순서는 Node v11.0.0을 기점으로 달라졌다. Node v11.0.0 이전에는 Node.js와 브라우저가 서로 다른 실행 순서를 따르고 있었기에 같은 자바스크립트 코드가 다른 결과를 보였기 때문이다.
따라서 브라우저와의 일관성을 위해 Node v11.0.0에서는 브라우저와 같은 실행 순서를 따르도록 변경되었다.

* 이전 버전에는 페이즈가 다음 페이즈로 넘어가기 전에 즉, 매 틱마다 nextTickQueue와 microTaskQueue를 검사했다.
  * Node v11.0.0 에서는 현재 실행하고 있는 작업이 끝나면 즉시 큐를 검사하고 실행하게 변경되었다.

이상으로 Node.js의 이벤트루프에 대한 간략한 정리였다.

이 글은 이하의 포스팅을 참조한 내용이므로 더 자세하게 정리된 내용은 해당 포스팅에서 확인 할 수 있다.   
[링크](https://www.korecmblog.com/node-js-event-loop/)
