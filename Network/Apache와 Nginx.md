# Apache와 Nginx
## Apache
Apache Software Foundation에서 만든 웹 서버 프로그램이다. 거의 모든 OS에서 실행, 문서화나 다른 소프트웨어 프로젝트와의 통합지원 등의 이점이 있다.
### 특징: 
* 스레드, 프로세스 기반 구조 
  * 클라이언트 요청당 하나의 스레드가 처리하는 구조
  * 사용자가 많으면 스레드 생성, 메모리 및 CPU낭비가 심하다.
* MPM(Multi-Process Module)
크게 두 방식, Prefork 방식과 Worker방식이 있다.
* 동적 컨텐츠 처리
* 다양한 모듈

### 단점:
* 클라이언트 접속 시 마다 프로세스 또는 스레드를 생성하는 구조이기 때문에 대량의 클라이언트(1만 이상)가 동시에 접속한다면 
CPU/메모리 사용량 증가 및 프로세스/스레드 생성비용이 드는 등 요청에 한계가 있다.
* Apache 서버의 프로세스가 blocking되면 요청을 처리하지 못하고 처리가 완료될 때까지 계속 대기한다.
  * Keep Alive(접속 대기)를 이용하면 해결이 가능하지만, Keep Alive 때문에 대량 접속시 효율이 떨어진다.

## Nginx 
Apache의 C10K 문제점(1만개 클라이언트 문제) 해결을 위해 만들어진 Event-Driven 구조의 웹서버 소프트웨어이다. 즉, 프로그램의 흐름이 이벤트에 의해 결정되는 방식이다.
### 특징:
* Event-Driven 처리 기반 구조
  * 한개 또는 고정된 프로세스만 생성하고 여러 개의 Connection을 모두 Event-Handler를 통해 비동기 방식으로 처리한다.
  * 적은 양의 스레드만 사용하기 때문에 Context Switching 비용이 적고 CPU 소모가 적다.
  * Apache와 달리 동시 접속자 수가 많아져도 추가적인 생성비용이 들지 않는다.
  * CPU와 관계없이 모든 I/O를 전부 Event-Listener로 미루기 때문에 흐름이 끊기지 않고 응답이 빠르게 진행되어 1개의 프로세스로 더 빠른 작업이 가능하다.
* 리버스 프록시로 배치 가능
  * Nginx의 빠른 처리 속도를 활용하여 클라이언트의 모든 요청을 처리한다.

### 단점:
* 동적 컨텐츠를 기본적으로 처리 할 수 없다. 외부 프로세서로 전달하고 렌더링 된 컨텐츠를 다시 전송 할 때까지 기다려야 한다.(프로세스 속도 저하)
* Apache에 비해 다양한 모듈이 없다.

### 결론
* Apache는 대규모 커뮤니티, 일반적인 문제 해결을 위한 많은 지원을 활용할 수 있어 안정성이 뛰어나다.
* Nginx는 대규모 동시 접속을 처리할 수 있고 CPU/메모리등 자원 소모가 적어 성능이 우수하다


___

#### Apache의 MPM
##### Prefork MPM
* Client 요청에 대해 Apache 자식 프로세스를 생성해 처리한다. 요청이 많을 경우 Process를 생성하는데, 이는 default로 설정되어 있다.
* 하나의 자식 프로세스 당 하나의 스레드를 갖는 구조로, 최대 1024개까지 가능하다.
* 스레드 간 메모리 공유를 하지않아 독립적이지만, 메모리 소모가 크다.
* 실행중인 프로세스를 복제하여 실행한다.(메모리 영역까지 복제)
* 응답 프로세스를 미리 띄워놓고 클라이언트 요청 시 자식 프로세시가 반응하는 방식이다.
* 디버깅이 빈약한 플랫폼에서 쉬운 디버깅이 가능하다.
* 일반적으로 Single CPU 또는 Dual CPU에서 성능이 더 좋다.
   
##### Worker MPM
* Prefork 보다 메모리 사용량이 적고, 동시 접속자가 많은 사이트에 적합하다.
* 각 프로세스의 스레드를 생성해 처리하는 구조이며 스레드 간 메모리 공유가 가능하다.
* 프로세스당 최대 64개의 스레드 처리가 가능하며 각 스레드는 하나의 연결만을 부여받는다.
* 일반적으로 Multi CPU시스템에서 성능이 좋다.

##### Context Switching
* Context: 스레드가 작업을 진행하는 동안 작업정보(레지스터, 커널스택, 사용자스택 등)를 보관한다.
* OS는 A작업을 진행할 때 A스레드의 Context를 읽어오며, B스레드로 전환 할 때 A스레드의 Context를 저장하고 B스레드의 Context를 읽어온다.
* 즉, 스레드의 갯수가 많아질 수록 Context Switching 작업은 빈번하게 일어나기 때문에 성능이 저하 될 수 있다.
