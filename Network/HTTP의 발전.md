# HTTP의 발전
## 개요
HTTP는 월드 와이드 웹에 내재된 프로토콜이다. HTTP는 본래의 단순함을 최대한 지키면서 확장할 수 있도록 많은 수정을 거쳐왔다.
### 월드 와이드 웹의 발명
1989년 CERN에서 인터넷 상의 하이퍼텍스트 시스템을 만들기 위한 제안이 작성되었고, 1990년에 월드 와이드 웹으로 구현되었다.
월드 와이드 웹은 기존의 TCP/IP 프로토콜 상에서 만들어지면서 4개의 빌딩 블록으로 구성되었다.

* 하이퍼 텍스트 문서를 표현하기 위한 텍스트 형식의 하이퍼텍스트 마크업 언어(HTML).
* 문서 등을 교환하기 위한 간단한 프로토콜인 하이퍼텍스트 전송 프로토콜(HTTP).
* 문서를 디스플레이하고 수정하기 위한 클라이언트인 월드 와이드 웹이라고 불리는 첫번째 브라우저.
* 문서에 접근하게 해주는 httpd의 초기 버전.

첫번째 서버는 1991년 초에 CERN 외부에서 가동을 시작했다.

### HTTP/0.9 - 원-라인 프로토콜 
HTTP 초기 버전에는 버전 번호가 없었다. HTTP/0.9는 이후에 차후 버전과 구별하기 위해 0.9로 불리게 되었다.
이 때의 HTTP는 극히 단순했다. 요청은 단일 라인으로 구성되며 리소스에 대한 경로로 가능한 메서드는 GET뿐이었다.

응답도 단순했는데, 오로지 파일 내용 자체로만 구성되었다. HTTP헤더도 없었고 이는 HTML파일만 전송가능 했고 다른 유형의 문서는 불가능했음을 의미한다.
상태, 오류 코드도 없었으며 문제 발생시 해당 파일 내부에 문제에 대한 설명과 함께 되돌려 보내졌다.

### HTTP/1.0 - 확장성 만들기 
* 버전 정보가 전송되기 시작했다.(HTTP/1.0이 GET라인에 붙은 형태)
* 상태 코드 라인이 응답의 시작 부분에 붙어 전송되어 요청에 대한 성공 여부를 알 수 있게 되었고, 그 결과에 대한 동작을 할 수 있게 되었다.
* HTTP헤더 개념은 요청과 응답 모두를 위해 도입되어, 메타데이터 전송을 허용하고 프로토콜을 유연하고 확장가능하게 만들어 주었다.
* 새로운 HTTP 헤더(Content-Type)로 HTML 파일 외 다른 문서를 전송하는 기능이 추가되었다.

이런 새로운 기능들은 합의된 것이 아니라 일단 해보자는 접근법으로 이루어졌다.

수많은 문제들로 인해 1996년 11월에 일반적인 실제 내용을 설명하는 정보 문서가 RFC1945에 공개되었다.
이것이 HTTP/1.0의 정의이며, 좁은 의미에서 공식적인 표준이 아니라는 것이 주목할 만한 점이다.

### HTTP/1.1 - 표준 프로토콜 
1995년 부터 다양한 HTTP/1.0 구현이 동시에 진행되었고, 그 이듬해 HTTP/1.0 문서 출간 전까지(1996년 문서 발행) 표준화도 진행중에 있었다. 
HTTP의 첫번째 표준 버전인 HTTP/1.1은 1997년 초에 공개되었다.

* 커넥션이 재사용할 수 있게 하여, 탐색된 단일 원본 문서 내로 임베드 된 리소스를 디스플레이하기 위해 사용된 커넥션을 다시열어 시간을 절약하게 했다.
* 파이프라이닝을 추가 했다. 첫번째 요청에 대한 응답이 완전히 전송되기 전에 두번째 요청 전송을 가능하게 하여 커뮤니케이션 레이턴시를 낮추었다.
* 청크된 응답도 지원된다.
* 추가적인 캐시 제어 메커니즘을 도입하였다.
* 언어, 인코딩 혹은 타입을 포함한 컨텐츠 협상이 도입되어 클라이언트와 서버 간 교환하려는 가장 적합한 컨텐츠에 대한 동의를 가능하게 했다.
* Host 헤더를 통해, 동일 IP 주소에 다른 도메인을 호스트할 수 있게 되었다.

HTTP/1.1은 1997년 1월에 RFC 2068에서 처음 공개되었다.

### 15년 동안의 확장
* 1999년 6월 RFC 2616 공개 및 HTTP/2 예견
* 2014년 6월 RFC 7230 - RFC 7235 시리즈
두번에 걸친 리비전틀 통해 정재되었음에도, 이 프로토콜은 15년 넘도록 안정성을 유지했다.

#### 보안 전송을 위한 HTTP 사용
HTTP에 일어났던 가장 큰 변화는 1994년 말에 이미 완료되었다.
넷스케이프 커뮤니케이션은 기본적인 TCP/IP 스택을 통해 HTTP를 전송하는 대신에, 그 토대 위에 추가적인 암호화된 전송계층인 SSL을 만들었다.
SSL 1.0은 회사 외부로 릴리즈 된 적이 없으며 SSL 2.0, SSL 3.0, SSL 3.1은 서버와 클라이언트 간에 교환된 메시지 인증을 암호화 및 보장하여 e-커머스 웹 사이트를 만들어내도록 했다.
SSL은 표준 트랙 상에 놓여져 있었고 마침내 TLS가 되어 취약성을 종식시키는 1.0, 1.1, 1.2 버전이 나와 있다. 현재 TLS 1.3은 진행중이다.

#### 복잡한 어플리케이션을 위한 HTTP 사용
1996년 쯤, HTTP는 저작을 허용하도록 확장되었고 WebDAV라는 표준이 만들어졌다. 
CardDAV, CalDAV 등도 있었지만, 이 모든 DAV 확장들은 사용하고 있는 서버에 의해 구현 되어야 하는 결점이 있었다.

2000년, Representational State Transfer(REST)라는 HTTP 사용에 대한 새로운 패턴이 고안되었다.
API에 의해 유도되는 액션들은 모든 웹 어플리케이션으로 하여금 브라우저나 서버의 갱신 없이 데이터 탐색과 수정을 허용하는 API 제공을 가능하게 했다. 
필요한 것은 표준 HTTP/1.1을 통해 웹 사이트에 의해 서브되는 파일 내로 임베드 되는 것이었다.

REST 모델의 단점은 각각의 웹사이트가 자신의 표준 RESTful API를 정의하고 그에 대한 전권을 가진다는 사실이다.
RESTful API는 2010년에 들어 매우 일반적인 것이 되었다.

#### 웹의 보안 모델 완화
HTTP는 웹의 보안 모델인 same-origin 정책에서 독립되어 있다. 현재의 웹 보안 모델은 모델은 HTTP가 만들어진 이후에 개발되어 왔다.
제약사항이 얼마나, 언제 리프트 될지는 HTTP 헤더의 새로운 묶음들을 사용하는 서버로부터 클라이언트에 의해 전도된다.
이런 내용은 Cross-Origin 리소스 공유(CORS) 또는 컨텐츠 보안 정책(CSP)과 같은 스펙 내에 정의되어 있다.

이런 커다란 확장 말고도 많은 헤더가 추가되고 있다.

주목할 만한 것으로 프라이버시를 제어하기 위한 Do Not Track(DNT)헤더, X-Frame-Options, Upgrade-Insecure-Request 등이 있다.

### HTTP/2 - 더 나은 성능을 위한 프로토콜
디스플레이되는 시각적 미디어의 양에 맞춰 상호작용을 추가하기 위한 스크립트의 양과 크기는 점점 더 증가하고 있다.
또 더 많은 데이터들이 더 많은 요청에 전송되고 있다.

HTTP/1.1 커넥션은 올바른 순서로 전송되는 요청을 필요로 한다. 몇몇 병렬 커넥션이 이론적으로 사용 가능한 경우에도 여전히 많은 양의 오버헤드와 복잡도가 남아 있다.
2010년 전반기에 Google은 실험적인 SPDY 프로토콜을 구현했고, SPDY는 HTTP/2 프로토콜의 기초로써 기여했다.

HTTP/2 프로토콜은 HTTP/1.1과 근본적인 몇가지 차이점이 있다.
* HTTP/2 프로토콜은 텍스트 프로토콜이라기 보다 이진 프로토콜이다. 더 이상 읽을 수도, 수작업을 만들어 낼 수 없다. 그러나 새로운 최적화 기술이 구현될 수 있다.
* 병렬 요청이 동일한 커넥션 상에서 다루어 질 수 있는 다중화 프로토콜이다. 순서를 제거해주고 HTTP/1.1의 제약사항을 막아준다.
* 전송된 데이터의 분명한 중복과 불필요한 오버헤드를 제거하고, 연속된 요청들의 매우 유사한 내용의 헤더를 압축한다.
* 서버 푸쉬라고 하는 메커니즘에 의해, 서버로 하여금 클라이언트 캐시를 사전에 필요하게 될 데이터로 채워넣도록 허용한다.

2015년 5월에 공식적으로 표준화 된 HTTP2는 2016년 6월 기준 모든 웹 사이트의 8.7%가 사용중이고, 이는 모든 요청의 68%이상을 나타낸다.

이런 급격한 채택은 HTTP/2가 웹 사이트와 웹 어플리케이션의 채택이 필요하지 않았기에 가능했다.
어느정도 제한된 액터 세트만이 HTTP/2 채택을 불러일으키는데 필요했고, 브라우저와 서버 버전이 교체됨에 따라 HTTP/2의 사용은 자연스럽게 증가했다.

#### 차세대 HTTP/2로의 진화
HTTP/1.x 처럼 확장성은 새로운 기능을 추가하는데 사용되고 있다. 
* Alt-Svc 지원은 좀더 영리한 CDN 메커니즘을 따라 신분 증명의 개념과 주어진 자원의 위치를 분리하도록 해준다.
* Client-Hints의 도입으로 브라우저 혹은 크라이언트가 요구사항이나 서버의 하드웨어 제약사항에 관한 정보를 사전에 주고 받을 수 있게 되었다.
* Cookie 내에 보안 관련 접두사 도입은 보안 쿠키가 변경되지 않았음을 보장하는데 도움을 준다.

### HTTP/3 - HTTP over QUIC
HTTP의 다음 메이저 버전인 HTTP/3에서는 전송 계층 부분에 TCP/TLS 대신 QUIC가 사용된다.
