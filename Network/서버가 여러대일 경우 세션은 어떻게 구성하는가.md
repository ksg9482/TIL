# 서버가 여러대일 경우 세션은 어떻게 구성하는가

## 서버와 세션 
세션은 서버 1대에 하나의 저장소가 형성된다. 서버가 여러대일 경우 나누어진 세션 저장소는 별도의 처리가 없으면 정합성 이슈가 발생한다. 여러대로 나뉜 서버가 하나의 서비스를 운영하기 위해서는 하나의 시스템처럼 동작하게 하거나, 고정된 세션을 사용해야 한다. 이하의 방법은 서버가 여러대일 경우 세션 간 정합성 이슈를 방지하기 위한 방법들이다.

### Sticky Session
유저가 세션에 고정되는 것을 의미한다. 유저가 특정 서버에서 세션을 생성하였다면, 이후에 그 유저가 보내는 모든 요청은 세션을 생성한 서버로만 보내지게 된다. 로드 밸런서는 세션을 생성한 서버로 모든 요청을 리다이렉트하여 고정된 세션만 사용하게 한다.   
   
이를 위해 로드 밸런서는 요청을 받으면 가장 먼저 요청에 쿠기가 존재하는가 확인한다. 쿠키가 있으면 해당 요청이 쿠키에 지정된 서버로 전송되고, 쿠키가 없으면 로드 밸런싱 알고리즘을 기반으로 서버를 선정한다.

그러나 고정된 세션을 사용한다는 것은 특정 서버에 트래픽이 집중될 위험이 있다. 서버에 트래픽이 집중되도라도 사용자는 다른 서버를 사용할 수 없다. 그리고 서비스 중에 하나의 서버에 장애가 발생하면 해당 서버를 사용하는 사용자들은 세션 정보를 잃게 된다.

### 세션 클러스터링 
여러대의 컴퓨터들이 연결되어 하나의 시스템처럼 동작하도록 만드는 것이 클러스터링이다.
All-to-all 세션 복제 방식. 하나의 세션 저장소에 변경되는 요소가 발생하면 변경된 사항이 다른 모든 세션에 복제된다. 복제되면 유저가 어떤 서버에 접속하더라도 로그인 정보가 세션에 저장되어 있어 정합성 이슈를 해결 할 수 있다. 
그러나 모든 서버가 동일한 세션 객체를 가져야 하기 때문에 많은 메모리가 필요하고 데이터가 저장 될 때마다 모든 서버에 값을 입력해야 하므로 서버 수와 비례해 트래픽이 증가한다. 즉, 소규모 클러스터(서버 3개 이하 수준)에서 좋은 성능을 보인다.

예를들어 JAVA 진영에서 자주 쓰이는 톰캣의 경우 Backup Manager를 활용한 primary-secondary 세션 복제 방식을 제시한다.
primary서버는 secondary(backup)서버에 세션 객체의 key-value 전체를 복제한다. 
하지만 이외의 서버에는 key에 해당하는 jsession id만을 복제하기에 메모리 사용량이 줄고 상대적으로 시간도 절약된다.
그러나 primary서버와 secondary서버를 제외한 proxy 서버에 세션 정보를 요청할 경우에는 다시 primary서버에 요청하여 해당 key에 해당하는 객체를 받아와야 한다.

### 세션 스토리지 분리
기존 서버가 갖고 있는 로컬 세션 저장소를 이용하는 방식이 아니라 별도의 세션 저장소를 사용한다. 로드 밸런싱 알고리즘이 잘 구현되어 있다는 전제하에 트래픽이 비정상적으로 몰리는 현상을 고려하지 않아도 된다.   
   
단, 세션 저장소도 세션 객체를 복제해야 할 필요가 있다. 하나의 세션 저장소를 운영한다는 것은 서버에 장애가 발생하면 모든 세션 이용이 불가능해진다는 뜻이다.
그렇기에 동일한 세션 저장소 하나를 더 구성하여 복제한다.