# 의존
기능 구현을 위해 다른 구성 요소를 사용하는 것.
```
예: 객체 생성, 메서드 호출, 데이터 사용
```
의존은 변경이 전파될 가능성이 있음을 의미한다. 의존하는 대상이 바뀌면, 의존 대상을 사용하는 쪽도 같이 바뀔 가능성이 높다.

* 호출하는 메서드의 파라미터 또는 파라미터 개수 변경
* 호출하는 메서드가 발생할 수 있는 예외 추가

```
순환의존이 위험한 이유가 이 때문. 의존이 순환해서 발생할 경우. 서로가 서로에게 변경을 전파한다.
의존하는 대상이 많다면? 각 대상이 별도의 이유로 변경되어도 모든 변경에 대응해야 한다. 그래서 의존하는 대상은 적을 수록 좋다.
```

### 의존 대상이 많을때 해결하는 방법

### 기능이 많은 경우 분리한다
* 한 클래스에서 많은 기능을 제공하는 경우.
  * 각 기능마다 의존하는 대상이 다를 수 있다.
  * 한 기능의 변경이 다른 기능에 영향을 줄 수 있다.
  * 기능 하나를 테스트하고 싶어도, 나머지 기능에서 필요로 하는 의존대상까지 함께 초기화 해야 하는 경우도 많아진다.

한 클래스가 제공하는 기능이 많으면 기능 별로 분리하는 것을 고려해야 한다. 
각 클래스 수는 늘어나지만, 각 클래스마다 필요로하는 의존이 줄어들고 한 기능을 수정할 때 다른 기능을 수정할 필요가 없게 된다.
그리고 개별 대상을 테스트하기 쉬워진다. 

### 의존 대상을 단일 기능으로 묶을 수 있는지 검토한다
몇 가지 의존 대상을 단일 기능으로 묶으면 의존 대상을 줄일 수 있다.
* 팩토리로 객체를 생성하고 리포지토리로 영속화 하는 경우 팩토리, 리포지토리에 의존성이 발생한다.
  * 등록 기능을 제공하는 Register로 묶으면 의존성은 Register로 줄어들고, 기능도 격리된다.

### 의존 대상 객체를 직접 생성하지 않고 사용하는 방법
* 팩토리, 빌더
* 의존성 주입(DI, Dependency Injection)
* 서비스 로케이터(Service Locator, 사용할 객체를 제공하는 책임을 가지는 객체)

### 의존성 주입(DI)
의존 객체를 직접 생성하지 않고 생성자나 메서드를 이용해여 주입 하는 형식.
프로그램을 시작하는 메인 메서드에서 의존 객체를 생성하고 주입할 수 있지만 보통은 조립기(Assembler)를 이용하여 객체를 생성하고 의존을 처리한다.
* Spring, NestJS 등 프레임워크

## DI 장점
* 상위 타입을 사용할 경우 의존 대상이 바뀌어도 조립기(설정)만 변경하면 된다.
* 의존하는 객체 없이 대역 객체를 사용해서 테스트 가능하다. 
  * 리포지토리등 실제 DB와 연결하지 않아도 DB와 연동하는 기능을 테스트 할 수 있다.
  * 대역을 이용하면 원하는 대로 상태를 초기화 할 수 있기 때문에 경우의 수를 테스트 하기 편하다.
