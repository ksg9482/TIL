# 기능분해

### 커다란 클래스와 메서드의 문제점
클래스나 메서드가 커지면 절차 지향과 동일한 문제가 발생 한다. 큰 클래스는 많은 필드를 많은 메서드가 공유하고, 큰 메서드는 많은 변수를 많은 코드가 공유하게 된다.

즉, 여러 기능이 한 클래스/메서드에 섞여있을 가능성이 높아진다.
```
예: 커다란 암호 변경 서비스 -> 변경 대상 찾기 + 암호 비교하기 + 암호 변경하기 등.
```

### 기능 분리와 분배
하나의 기능은 여러 하위기능으로 분리 할 수 있다. 분리한 하위기능을 누가 제공할 것인가를 결정하는게 객체지향 설계의 기본 과정.
기능은 곧 책임이며, 분리한 각 기능을 제공할 책임을 분배한다.
* 암호변경
  * 암호변경 서비스 자체: ChangePasswordService(서비스)
  * 변경 대상 확인: MemberRepository(DB)
  * 대상 암호 변경: Member(Domain)

### 클래스와 메서드가 커지지 않도록 책임을 분리하는 방법
패턴 적용, 계산 기능 분리, 외부 연동 분리, 조건별 분기 추상화 등을 이용한다.
##### 패턴 적용
역할에 맞게 분리한다.
* 간단한 웹: 컨트롤러, 서비스, DAO
* 복잡한 도메인: 엔티티, Value, 리포지토리, 도메인 서비스
* AOP: Aspect(공통기능)
* GoF: 팩토리, 빌더, 전략, 템플릿 메서드, 프록시, 데코레이터 등 디자인 패턴

##### 계산 기능 분리
예: 포인트 계산 로직 -> PointCaculator 클래스로 분리
* 계산을 서비스에서 직접 하는 것이 아니라 PointCaculator 객체에 위임하고 값을 받음.

##### 외부 연동 분리
네트워크, 메시지, 파일 등 외부 연동이 필요한 코드를 별도 클래스로 분리

##### 조건별 분기 추상화
연속적인 if-else 블록이 있는데, 각 if에서 하는 일이 실제로 비슷하다면 공통점을 이용하여 추상화

### 역할을 분리할때 주의점
의도가 드러나는 이름을 사용해야 한다. 예를 들어HTTP로 추천 데이터를 읽어오는 기능을 분리할 경우 
HttpDataService보다 Recommandservice 등 추천과 관련된 기능인 것을 알 수 있는 이름을 사용한다.

### 역할 분리의 장점
테스트가 쉬워진다. 예를 들어 계산 기능을 분리했을 경우, repository 등을 거치지 않기 때문에 테스트 코드를 통해 임의의 값을 입력하여 외부의 영향 없이 기능 검증을 할 수 있다. 
