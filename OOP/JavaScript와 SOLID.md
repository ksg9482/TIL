# JavaScript와 SOLID
## SOLID
객체 지향 프로그래밍 및 설계의 5가지 기본 원칙이며, 목적은 시간이 지나도 유지 보수와 확장이 쉬운 시스템을 만드는 것이다. 소프트웨어 작업에서 프로그래머가 소스 코드를 읽기 쉽고 확장하기 쉽도록 소스 코드를 리팩토링 할 때 적용 할 수 있는 지침이기도 하다.   
   
### 왜 필요한가?
요구사항과 환경이 매번 변하는 만큼 코드도 끊임 없이 변화하게 된다. 그러나 소프트웨어는 거대한 기계와도 같아서 일부를 교체하는 것이 전체의 고장으로 이어지기도 한다.   
   
SOLID 원칙을 적용하여 서로간의 종속성을 최소화 하면 변경이 발생했을 때 다른 영역에 영향을 주지 않고 변경할 수 있게 되고 문제가 생겨도 그 범위를 최소화 할 수 있다.   

### 그렇다면 JavaScript에서는?
SOLID를 준수하는 것은 클래스 구조로 객체를 만드는 방식이 일반적인 객체지향적인 언어(대표로 JAVA)에서는 적용하기 쉽지만, 함수 위주로 작성하는 JavaScript(TypeScript)에서는 적용하기 쉬울까?   
   
JavaScript는 함수형 프로그래밍을 기반으로 JAVA의 모습을 따온 언어이다. 그렇기에 함수형의 성격과 객체지향의 성격을 동시에 지닌다. 심지어 class 문법도 일반적인 객체지향과 다르기에 배워도 실전에서 사용하기는 힘들다. 그러나, SOLID는 객체지향을 기반으로 하지만 함수와 데이터, 타입에 대한 이야기이니 꼭 객체지향만을 위한 것이 아니라는 점이 중요하다.   
   
즉, SOLID가 객체지향을 바탕으로 설명하는 부분은 사실이기에 JavaScript에 SOLID를 적용하려면 SOLID원칙을 함수 위주 방식에 어떻게 적용할 지 봐야할 것이다.

### S (Single Responsibility Principle 단일 책임 원칙)
함수는 오직 하나의 책임을 가져야 한다. 즉, 함수는 오직 하나의 변경 이유를 가져햐 한다는 뜻이다. 같은 이유로 변경될 코드는 모으고, 다른 이유로 변경될 코드는 흩어라.   
   
함수는 한 가지 작업을 수행해야 한다는 것은 가장 중요한 규칙이다. 함수가 한 가지 이상을 수행할 때 구성을 추론, 테스트하기 힘들다. 함수를 한 가지 작업만 하도록 분리하면 문제가 발생했을 때 확인해야 하는 코드의 양이 줄어든다.   
   
그렇다면 어디를 어떻게 쪼개야 할까? 우선 가장 기본적으로 쪼개야 할 것은 다음과 같다.
* filter()에 들어갈 조건 판별 함수
* forEach()에 들어가 동작을 하는 side-effect 함수
* map()에 들어가는 project 함수
* sort()에 들어가는 정렬을 나타내는 함수

또 너무 잘게 쪼개는 것도 능사가 아니다. 상황에 따라 달라지기에 융통성이 필요하다.
* 재사용이나 변경의 여지가 있는가?
* 함수명이 표현식보다 더 가독성이 좋은가?
* 함수 분리로 인해 오히려 전체 파이프라인을 오고가게 되서 이해하는데 방해가 되지 않는가?
* 하나의 파이프라인에 속한 함수로 쪼개져 있어서 응집도가 떨어지진 않았는가?
   
가독성과 응집도를 기준으로 적절히 inline을 사용하는 것도 방법이다. 가독성의 기준은 본인이 아니라 이 코드를 읽는 다른 사람이다.
    
#### SRP와 순수함수
함수형 프로그래밍은 순수함수와 부수효과를 분리하는 구조가 되어야 한다. 순수 함수는 다음과 같은 특징을 지닌다.
* 1개의 반환값이 반드시 존재한다.
* 같은 인자를 넣었을 때 항상 같은 값을 반환한다.
* 외부의 어떤 값을 변화시키지 않는다.
이러한 순수함수의 특징은 SRP원칙에 부합한다. 함수형 프로그래밍의 핵심인 순수함수로 작성해야 한다는 원칙은 SOLID의 첫번째 원칙인 SRP와 엮어서 생각하는 것이 좋다.

### O (OCP Open/Close Principle 개방-폐쇄 원칙)
소프트 웨어는 확장에는 열려있어야 하지만 변경에는 닫혀 있어야 한다. OCP원칙은 새로운 기능의 추가가 일어났을 때 기존 코드의 수정 없이 추가가 되어야 하고, 내부 매커니즘의 변경이 있을 때 외부 코드의 변화가 없어야 한다는 의미이다.   
   
함수형 프로그래밍에서 OCP를 가장 잘 나타내주는 것은 map(), filter()와 같은 고차함수(Higher order function), 플러그인, 미들웨어 개념이다.   
   
하나의 함수가 여러 옵션으로 인해 내부에서 분기가 많이 발생하고 있다면 OCP와 SRP 원칙에 맞게 함수를 매개변수로 받는 방법을 통해 공통 매커니즘 코드와 새로운 기능에 대한 코드를 분리 할 수 있다.

* 덩치가 큰 함수라면 일단 OCP와 SRP 원칙으로 점검해 본다.
* 만약 버그수정이 아니라 새로운 기능을 개발 할 때, 기존 함수를 수정하며 코드를 개발하고 있다면 OCP 원칙을 위반하고 있을 가능성이 높다.

### L (Liskov Substitution Principle 리스코프 치환 원칙)
프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다. 즉, 상위 타입과 그 상위 타입을 상속 받은 하위타입은 서로 치환해도 문제가 없어야 한다.

#### 전형적인 위반
가장 전형적인 예를 들어보자면 직사각형 클래스로부터 정사각형 클래스를 파생하는 경우이다. 정사각형은 항상 너비와 높이가 같다고 간주 할 수 있는데, 정사각형의 크기(너비 또는 높이로)는 독립적으로 변경할 수 없다. 만약 정사각형이 직사각형을 다루는 문맥에서 사용되는 경우 예기치 못한 행동을 할 수 있다.   
   
이 문제는 고치기 힘들뿐더러 정사각형의 불변조건인 너비와 높이가 같음을 유지하면 직사각형 할당자의 사후 조건(크기를 독립적으로 변경 할 수 있다)을 위반하게 된다.   
   
너비 또는 높이를 변경하는 메서드를 사용할 경우 직사각형은 독립적으로 어느 하나만 바꿀 수 있지만(20 x 10 -> 높이를 30으로 -> 20 x 30), 정사각형은 너비와 높이가 같기 때문에 강제적으로 너비와 높이 전부 변경된다(10 x 10 -> 높이를 30으로 -> 30 x 30).

#### 왜 LSP가 만들어졌나?
상속을 받아 만든 하위 타입의 제약 조건들이 상위 타입에서 먼저 선언한 조건들과 충돌이 날 경우 유지보수가 힘들어지기 때문에 만들어 졌다. 따라서 계츨도간 is-a 관계를 만족하더라도 하위타입에서 가변성을 가지면서 상위 타입에서 정의한 조건과 일치하지 않으면 상속을 받지 말아야 한다.

#### 함수형 프로그래밍에서는?
LSP 원칙은 상속을 기반하므로 함수형 프로그래밍에 바로 적용하기는 힘들다. 하지만 먼저 선언된 조건들과 나중에 선언된 조건들이 서로 충돌하지 말아야 한다는 원칙으로 접근할 수 있다. 이렇게 접근한다면 선언형 함수형 프로그래밍에서 발생하는 순환 종속성을 만들어내는 Infinite Cycle을 만들지 말아야 한다는 원칙으로 대체할 수 있다.

### I (ISP Interface Segregation Principle)
사용자가 필요하지 않은 것들에 의존하지 않도록, 인터페이스를 작게 유지하라. 하지만 함수형 프로그래밍에서는 사실 함수와 인터페이스가 1:1 관계이기에 ISP 원칙을 위반하는 것이 쉽지 않다.   
   
만약 ISP와 함수형 프로그래밍(특히 타입스크립트)의 경우를 보자면, 백엔드 스키마 정의를 인터페이스를 정의하여 사용하게 되는데 스키마 외에 클라이언트에서 필요한 필드들을 추가하고 스키마를 맞추기 위해 ?를 통해 optional한 필드로 만드는 경우가 ISP 위반으로 볼 수도 있을 것이다.   
   
optional을 사용하지 않고 필수 property만 존재하는 인터페이스에 필요한 property를 담은 인터페이스를 extend하여 새로운 interface를 사용하는 것도 권장 할 만 하다. 단, optional이어야 하는 경우와 interface를 분리해야하는 경우를 잘 따져야 할 것이다.
   
또다른 측면으로는 '크기'에 대해서도 말할 수 있다. 하나의 모듈에 너무 많은 기능을 넣어서 덩치를 키우는 것을 지양하고, 함수로 쪼개는 것을 지향한다.

### D (DIP Dependency Inversion Principle)
추상화에 의존해야지, 구체화에 의존해서는 안된다. 추상화하는 방향으로 의존한다는 것은 상위 레벨 모듈이 하위 레벨 세부 사항에 의존해선 안된다는 뜻이다.   
   
추상화된 레이어를 두어서 사용하는 측의 코드를 변화없이 변경 할 수 있도록 한다. 



[출처](https://velog.io/@teo/Javascript%EC%97%90%EC%84%9C%EB%8F%84-SOLID-%EC%9B%90%EC%B9%99%EC%9D%B4-%ED%86%B5%ED%95%A0%EA%B9%8C)