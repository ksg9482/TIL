# 2장 - 이상한 나라의 객체

## 객체지향과 인지능력 
인간은 좀 더 작은 객체로 주변을 분해함으로 세상을 이해하려 노력한다. 객체란 인간이 분명하게 인지하고 구별할 수 있는 경계를 지닌 어떤 것이다.
객체지향 패러다임은 소프트웨어 세계 역시 다양한 소프트웨어 객체들이 모여 이루어져 있다는 믿음에서 출발한다.

그러나 소프트웨어 세계는 현실의 객체와 다른 모습을 보인다. 소프트웨어 세계의 전등은 스스로 불을 키고, 차는 스스로 시동을 걸고, 통장은 스스로 금액을 인출한다.
객체지향 패러다임의 목적은 현실세계의 모방이 아니라 현실을 기반으로 하는 다른 세계의 창조인 것이다.

하나의 개별적인 실체로 식별 가능한 것은 어떤 것이라도 객체가 될 수 있다. 
객체의 다양한 특성을 설명하기 위해서는 객체를 상태(state), 행동(behaviior), 식별자(identity)를 지닌 실체로 보는 것이 효과적이다.

## 상태
어떤 행동의 결과는 과거에 어떤 행동들이 일어났었느냐에 의존한다. 일반적으로 과거에 발생한 행동의 이력을 통해 현재 발생한 행동의 결과를 판단하는 것은 복잡하고 번거롭다. 

그래서 행동의 과정과 결과를 단순하게 기술하기 위해 상태라는 개념이 고안되었다. 과거 행동들을 모르더라도 행동들로 변경된 상태를 통해 판단을 내릴 수 있다. 

상태를 이용하면 현재를 기반으로 객체의 행동방식을 이해할 수 있다.

#### 상태와 프로퍼티
객체의 상태는 단순한 값과 객체의 조합으로 표현 할 수 있다. 이때 객체의 상태를 구성하는 모든 특징을 통틀어 객체의 프로퍼티(property)라고 한다. 
일반적으로 프로퍼티는 정적이다. 그러나 프로퍼티 값은 동적이다. 시간의 흐름에 따라 변경되기 때문이다. 

프로퍼티는 속성과 연관관계라는 두 종류로 구분할 수 있다. 속성을 단순한 값으로 표현된다. 객체 사이의 의미있는 연결을 링크(link)라고 하는데 연관관계는 정적인 관계를 의미하며 링크는 연관관계의 인스턴스이다.

객체지향의 기본 사상은 상태와 상태를 조작하기 위한 행동을 하나의 단위로 묶는 것이다. 이 때, 스스로의 행동에 의해서만 상태가 변경되는 것을 보장함으로써 객체의 자율성을 유지한다.

## 행동
객체가 취하는 행동은 객체 자신의 상태를 변화시킨다. 이는 부수효과(side effect)를 초래하는 것이며 부수효과의 개념을 이용하면 객체의 행동을 상태 변경의 관점에서 쉽게 기술 할 수 있다.
객체의 행동은 객체의 상태를 변화시키지만, 행동의 결과는 객체의 상태에 의존적이다. 상태의 개념을 이용해 행동을 두 관점에서 서술할 수 있다.

* 상호작용이 현재 상태에 어떤 방식으로 의존하는가
* 상호작용이 현재 상태를 어떻게 변경시키는가

#### 협력과 행동
객체가 다른 객체와 협력하는 유일한 방법은 다른 객체에 메시지를 보내는 것이다. 요청을 수신한 객체는 요청을 처리하기 위해 행동한다.
객체의 행동은 객체가 협력에 참여하는 유일한 방법이다. 

객체가 행동하게 하는 것은 외부에서 수신된 메시지이고, 그 결과로 자신의 상태를 변경한다.
그리고 협력에 참여하는 객체는 자신의 상태변경 뿐만아니라 다른 객체의 상태변경도 유발한다.

행동이란 외부의 요청(메시지)에 응답하기 위해 동작하고 반응하는 것이다. 행동의 결과로 객체는 자신의 상태를 변경하거나 다른 객체에 메시지를 전달한다. 객체는 행동을 통해 다른 객체와의 협력에 참여하므로 행동은 외부에 가시적이여야 한다.

#### 상태 캡슐화
모든 객체는 자신이 자신의 상태를 관리하는 자율적인 존재이다. 객체의 행동을 유발하는 것은 외부로부터 전달된 메시지지만 객체의 상태를 변경할지 여부는 객체 자신이 결정한다.
메시지를 송신하는 객체는 메시지를 수신하는 객체의 상태가 변경되는 것을 알지도 못한다. 객체가 외부에 노출하는 것은 행동뿐이며 상태는 노출하지 않기 때문이다. 

상태를 외부에 노출하지 않고 행동을 경계로 캡슐화하는 것은 객체의 자율성을 높인다. 자율적인 객체는 스스로 판단하고 결정하기 때문에 객체의 지능이 높다. 협력에 참여하는 객체들의 지능이 높을수록 협력은 유연하고 간결해진다.


## 식별자
객체가 식별 가능하다는 것은 서로를 구별할 수 있는 특정한 프로퍼티가 객체안에 존재한다는 것을 뜻한다. 이 프로퍼티를 식별자라고 한다. 
모든 객체가 식별자를 가진다는 것은 반대로 객체가 아닌 단순한 값은 식별자를 가지지 않는다는 것을 뜻한다. 

#### 동등성
값은 숫자, 문자열, 시간 등 변하지 않는 양을 모델링 한다. 값의 상태는 변하지 않기 때문에 흔히 불변 상태(immutable state)를 가진다고 말한다.
값의 경우 두 인스턴스의 상태가 같다면 두 인스턴스를 같은 것으로 판단한다. 

상태를 이용해 두 값이 같은지 판단할 수 있는 성질을 동등성(equality)라고 한다.
상태를 이용해 동등성을 판단할 수 있는 이유는 값의 상태가 변하지 않기 때문이다. 값은 오직 상태만으로 동등성을 판단하기 때문에 별도의 식별자를 필요로 하지 않는다.

#### 동일성
객체는 시간에 따라 변경되는 상태를 포함하며, 행동을 통해 상태를 변경한다. 따라서 객체는 가변 상태(mutable state)를 가진다. 타입이 같더라도 두 객체는 독립적인 별개의 객체다.
두 객체의 상태가 다르더라도 식별자가 같다면 두 객체를 같은 객체로 판단할 수 있다. 

식별자를 기반으로 객체가 같은지 판단할수 있는 성질을 동일성(identical)이라 한다.
상태를 기반으로 객체의 동일성을 판단할 수 없는 이유는 시간의 흐름에 따라 객체의 상태가 변하기 때문이다. 따라서 상태가 가변적인 두 객체의 동일성을 판단하기 위해서는 상태 변경에 독립적인 별도의 식별자를 이용해야 한다.

#### 값과 객체를 혼란스러워하는 이유?
대부분의 객체지향 언어에서는 두 개념 모두 클래스를 통해 구현되기 때문이다. 프로그래밍 언어의 관점에서 값과 객체 모두 클래스로 부터 생성된 객체이기 때문에 문맥에 따라 혼란스러워질 수 있다.

오해를 줄이기 위해 식별자를 지닌 객체는 참조 객체(reference object), 엔티티(entity)로 표현하고 값 객체(value object)는 식별자를 가지지 않는 값을 표현하곤 한다.

객체 지향의 세계는 상태가 변하지 않는 값과 상태가 변하는 객체들이 서로 균형을 맞추며 조화로워야 한다.

* 객체는 상태를 가지며, 상태는 변경 가능하다.
* 객체의 상태를 변경시키는 것은 객체 자신의 행동이다.
  * 행동의 결과는 상태에 의존적이다.
  * 행동의 순서는 실행 결과에 영향을 준다.
* 객체는 어떤 상태에 있더라도 식별가능 하다(상태가 다르더라도 식별자를 통해 식별 가능하다).

## 행동이 상태를 결정한다.
상태를 먼저 고려하고 행동을 나중에 결정하는 방법은 설계에 나쁜 영향을 끼친다.
* 캡슐화 저하.
  * 상태에 초점을 맞추면 상태가 객체 내부에 깔끔하게 캡슐화 되지 못하고 공용 인터페이스에 그대로 노출될 위험이 높아진다.
* 객체를 고립시킨다.
  * 상태를 먼저 고려하면 협력이라는 문맥에서 객체를 벗어나게 한 채 객체를 설계하게 한다.
* 재사용성 저하
  * 객체의 재사용성은 다양한 협력에 참여할 수 있는 능력에서 나온다. 상태에 초점을 맞춘 객체는 다양한 협력에 참여하기 어렵다.

객체 지향에서 초점을 맞춰야 하는 것은 상태가 아니라 행동이다. 객체는 다른 객체와 협력하기 위해 존재하고, 행동은 객체가 협력에 참여하는 유일한 수단이다.
행동을 결정한 후에야 행동에 필요한 정보가 무엇인지를 고려하게 되며 이 과정에서 필요한 상태를 선택하게 된다.

협력 안에서 객체의 행동은 객체가 협력에 참여하면서 완수해야 하는 책임을 의미한다. 따라서 어떤 책임이 필요한가를 결정하는 과정이 전체 설계를 주도해야 한다.

## 객체의 의인화
객체지향은 현실세계의 단순한 모방이 아니다. 현실속 객체와 소프트웨어 객체의 가장 큰 차이는 능동성이다. 현실의 상품은 스스로 가격 계산을 하지 못하지만 소프트웨어 객체의 상품은 스스로 가격 계산을 수행 할 수 있다.

이것은 단순화나 추상화가 아니라 특성이 전혀 다른 어떤 것임을 의미한다. 모방과 추상화라는 개념만으로는 현실 객체와 소프트웨어 객체의 관계를 깔끔히 설명하지 못한다.

객체지향 세계는 현실 세계를 참조할 뿐 궁극적인 목적은 새로운 세계를 창조하는 것이다. 현실세계와 객체지향 세계의 관계를 좀 더 정확히 설명할 수 있는 단어는 은유(metaphor)이다. 
현실세계 속 객체의 의미 일부가 소프트웨어 객체로 전달되기 때문에 프로그램 내의 객체는 현실 속 객체에 대한 은유다.

은유 관계에 있는 실제 객체의 이름을 소프트웨어 객체의 이름으로 사용하면 표현적 차이를 좁혀 소프트웨어의 구조를 쉽게 예측 할 수 있다.
여기서 차이란 소프트웨어에 대해 사람들이 생각하는 모습과 실제 소프트웨어의 표현 사이의 차이를 의미한다. 

은유를 효과적으로 이용하면 표현적 차이를 줄이고 이해하기 쉽고 유지보수가 쉬운 소프트웨어를 만들 수 있다.
현실을 닮아야 한다는 제약이 아니라 객체의 특성을 상기시키기 쉽기 때문에 현실세계의 이름으로 묘사한 것일 뿐이다. 필요하다면 현실세계를 깔끔하게 무시하고 새로운 세계를 창조해도 된다.
