1장 타입스크립트 알아보기

* 아이템 1 타입스크립트와 자바스크립트의 관계 이해하기
  * 타입스크립트는 자바스크립트의 상위집합이다.
  * 타입스크립트의 타입 시스템은 런타임시 오류를 발생시키는 코드를 찾는다. 그러나 타입 체커를 통과하며 런타임 오류를 발생시키는 코드도 존재한다.
  * 자바스크립트에서는 허용되지만 타입스크립트에서는 허용되지 않는 경우가 있다. 이런 문법의 엄격함은 취향 차이로 제어 할 수 있다.

* 아이템 2 타입스크립트 설정 이해하기
  * 타입스크립트 설정은 tsconfig.json을 이용하는 편이 좋다.
  * 프로젝트 초기에 noImplictitAny를 설정하는 편이 좋다.
  * 엄격한 체크를 하고 싶다면 strict 설정을 고려할만 하다. 특히 strictNullChecks를 설정하면 일부 런타임 오류를 방지할 수 있다.

* 아이템 3 코드 생성과 타입이 관계없음을 이해하기
  * 코드 생성은 타입 시스템과 별개이다. 타입은 런타임에 제거되기 때문에 타입 에러가 있더라도 컴파일은 가능하다.
  * 런타임에 타입을 지정하기 위해선 타입 정보 유지를 위한 별도의 방법이 필요하다. 

* 아이템 4 구조적 타이핑에 익숙해지기
  * 자바스크립트는 덕타이핑(duck typing) 기반이고 타입스크립트는 이를 모델링하기 위해 구조적 타이핑을 사용한다.
  * 클래스 역시 구조적 타이핑을 따른다. 클래스 인스턴스가 예상과 다를 수 있다. 
  * 구조적 타이핑을 시용하면 유닛 테스팅을 손쉽게 할 수 있다.


* 아이템 5 any 타입 지양하기
  * any 타입은 타입 체커와 타입스크립트 언어 서비스를 무력화 한다. 최대한 사용을 피하자.

2장 타입스크립트의 타입 시스템

* 아이템 6 편집기를 사용하여 타입 시스템 탐색하기
  * 편집기를 사용하면 어떻게 타입 시스템이 동작하는지, 어떻게 타입을 추론하는지 개념을 잡을 수 있다.
  * 타입 선언 파일을 살펴보면 타입스크립트가 동작을 어떻게 모델링하는지 알 수 있다.

* 아이템 7 타입이 값들의 집합이라고 생각하기
  * 타입을 값의 집합이라 생각하면 이해하기 편하다. 타입스크립트의 타입이란 엄격한 상속관계가 아니라 겹쳐지는 집합으로 표현된다.
  * 타입 연산은 집합의 범위에 적용된다. 'A는 B를 상속', 'A는 B에 할당가능', 'A는 B의 서브타입' 등의 표현은 'A는 B의 부분집합'이라는 뜻이다.
  
* 아이템 8 타입 공간과 값 공간의 심벌 구분하기
  * 모든 값은 타입을 가지지만 타입은 값을 가지지 않는다. 타입스크립트 코드를 볼 때, 타입인지 값인지 구분하는 방법을 터득해야 한다. 
  * type, interface 등의 키워드는 타입 공간에만 존재한다. 그러나 class, enum 같은 키워드는 타입과 값 두가지로 사용될 수 있다.
  * 'foo'는 문자열 리터럴(type: 'foo') 이거나 문자열 리터럴 타입(type: string)일 수 있다. 차이점을 알고 구별해야 한다.
  * typeof, this, &, | 등의 키워드나 연산자는 타입 공간과 값 공간에서 다른 목적으로 사용될 수 있고 다른 의미를 가진다. 

* 아이템 9 타입 단언보다는 타입 선언을 사용하기
  * 타입 단언은 'as Type'방식을 뜻하고, 타입 선언은 ': type'방식을 뜻한다.
  * 만약 타입스크립트보다 타입 정보를 더 잘 알고 있는 상황이라면 타입 단언문과 null아님 단언문(접미 '!')을 사용하면 된다.

* 아이템 10 객체 래퍼 타입 피하기
  * 직접 사용하거나 인스턴스를 생성하는 것은 피해야 한다. String 타입과 string 타입은 서로 다르다.
  * 타입스크립트는 기본형과 객체 래퍼 타입을 별도로 모델링한다. 객체 래퍼 타입(String)은 지양하고 기본형 타입(string)을 사용해야 한다.

* 아이템 11 잉여 속성 체크의 한계 인지하기
  * 객체 리터럴을 변수에 할당하거나 함수에 매개변수로 전달할 때 잉여 속성 체크가 수행된다. 
  * 일반적인 구조적 할당 체크와 잉여 속성 체크는 역할이 다르기 때문에 개념을 알고 구분해야 한다.
  * 임시 변수를 도입하면 잉여 속성 체크를 건너 뛸 수 있다는 한계가 있다.

* 아이템 12 함수 표현식에 타입 적용하기
  * 함수 문장(function abc(){...})과 함수 표현식(const abc = function(){...} / const abc = () => {...})은 다르게 인식된다. 
  * 함수의 매개변수 부터 반환값까지 전체를 함수 타입으로 선언하여 함수 표현식에 재사용할 수 있기 때문에 타입스크립트에서는 함수 표현식을 사용하는 것이 좋다.
  * 같은 타입 시그니처를 반복적으로 작성한 코드가 있다면 함수 타입을 분리해내거나 이미 존재하는 타입을 찾는다. 다른 함수의 시그니처를 참조하려면 typeof fn을 사용하면 된다.

* 아이템 13 타입과 인터페이스의 차이점 알기
  * 한 타입을 type과 interface 두 가지 문법으로 사용하는 방법을 알고, 비슷한 점과 차이점을 이해해야 한다.
  * 어떤 문법을 사용할지는 한가지 일관된 스타일을 확립하고, 보강 기법이 필요한지 고려해야 한다. 복잡한 타입이라면 타입 별칭을 사용하고, 간단한 객체 타입이라면 일관성과 보강의 관점에서 고려하면 된다. 
  * 향후에 보강 가능성이 있다면 인터페이스를 사용하여 새 필드 병합의 여지를 두는 것이 좋다. 그러나 프로젝트 내부적으로 사용되는 타입에 선언 병합이 발생하는 것은 잘못된 설계이다. 이럴 때는 타입을 사용해야 한다.

* 아이템 14 타입 연산과 제너릭 사용으로 반복 줄이기
  * DRY(Don't Repeat Yourserf) 원칙을 타입에도 적용하라. 타입에 이름을 붙여 반복을 피하고, extends를 사용하여 인터페이스 필드의 반복을 피해야 한다.
  * keyof, typeof, 인덱싱, 매핑된 타입등 타입스크립트가 제공하는 도구들을 공부해야 한다. 
  * 제네릭 타입은 타입을 위한 함수이다. 제네릭 타입을 활용하여 타입들 간에 매핑을 하고, 제네릭 타입을 제한하려면 extends를 사용하면 된다. Pick, Partial등 제네릭 타입에 익숙해져야 한다.

* 아이템 15 동적 데이터에 인덱스 시그니처 사용하기
  * 런타임 때까지 객체의 속성을 알 수 없을 경우(CSV 파일을 로드하는 등)에만 인덱스 시그니처를 사용한다.
  * 가능하다면 인덱스 시그니처 보다 인터페이스, Record, 매핑된 타입 등 정확한 타입을 이용하는 것이 좋다. 안전한 접근을 원한다면 인덱스 시그니처의 값 타입에 undefined를 추가하는 것을 고려해야 한다.

* 아이템 16 number 인덱스 시그니처보다는 Array, 튜플, ArrayLike를 사용하기
  * 숫자로 키를 만들어도 배열은 객체이기 때문에 키는 숫자가 아니라 문자열이다. 인덱스 시그니처로 사용된 number타입은 버그를 잡기위한 순수 타입스크립트 코드이다.
  * 인덱스 시그니처에는 number보다 Array, 튜플, ArrayLike 타입을 사용하는 것이 좋다.

* 아이템 17 변경 관련된 오류 방지를 위해 readonly 사용하기
  * 함수가 매개변수를 수정하지 않는다면 readonly를 선언하는 것이 좋다. readonly 매개변수는 인터페이스를 명확하게 하며, 매개변수 변경을 방지한다.
  * const와 readonly의 차이를 이해해야 한다.
  * readonly는 얕게 동작한다. 만약 객체의 readonly 배열이 있다면 그 객체 자체는 readonly가 아니다. 현재 시점에서는 깊은 readonly 타입이 기본으로 지원되지 않기 때문에 제너릭을 이용하거나 라이브러리를 사용해야 한다. 

* 아이템 18 매핑된 타입을 사용하여 값을 동기화하기
  * 매핑된 타입을 사용해서 관련된 값과 타입을 동기화 하도록 한다. 매핑된 타입은 한 객체가 또 다른 객체와 정확히 같은 속성을 가지게 할 때 이상적이다.
  * 인터페이스에 새로운 속성을 추가할 때, 선택을 강제하도록 매핑된 타입을 고려해야 한다.

3장 타입 추론

* 아이템 19 추론 가능한 타입을 사용해 장황한 코드 방지하기
* 아이템 20 다른 타입에는 다른 변수 사용하기
* 아이템 21 타입 넓히기
* 아이템 22 타입 좁히기
* 아이템 23 한꺼번에 객체 생성하기
* 아이템 24 일관성 있는 별칭 사용하기
* 아이템 25 비동기 코드에는 콜백 대신 async 함수 사용하기
* 아이템 26 타입 추론에 문맥이 어떻게 사용되는지 이해하기
* 아이템 27 함수형 기법과 라이브러리로 타입 흐름 유지하기

4장 타입 설계

* 아이템 28 유효한 상태만 표현하는 타입을 지향하기
* 아이템 29 사용할 때는 너그럽게, 생성할 때는 엄격하게
* 아이템 30 문서에 타입 정보를 쓰지 않기
* 아이템 31 타입 주변에 null 값 배치하기
* 아이템 32 유니온의 인터페이스보다는 인터페이스의 유니온을 사용하기
* 아이템 33 string 타입보다 더 구체적인 타입 사용하기
* 아이템 34 부정확한 타입보다는 미완성 타입을 사용하기
* 아이템 35 데이터가 아닌, API와 명세를 보고 타입 만들기
* 아이템 36 해당 분야의 용어로 타입 이름 짓기
* 아이템 37 공식 명칭에는 상표를 붙이기

5장 any 다루기

* 아이템 38 any 타입은 가능한 한 좁은 범위에서만 사용하기
* 아이템 39 any를 구체적으로 변형해서 사용하기
* 아이템 40 함수 안으로 타입 단언문 감추기
* 아이템 41 any의 진화를 이해하기
* 아이템 42 모르는 타입의 값에는 any 대신 unknown을 사용하기
* 아이템 43 몽키 패치보다는 안전한 타입을 사용하기
* 아이템 44 타입 커버리지를 추적하여 타입 안전성 유지하기

6장 타입 선언과 @types

* 아이템 45 devDependencies에 typescript와 @types 추가하기
* 아이템 46 타입 선언과 관련된 세 가지 버전 이해하기
* 아이템 47 공개 API에 등장하는 모든 타입을 익스포트하기
* 아이템 48 API 주석에 TSDoc 사용하기
* 아이템 49 콜백에서 this에 대한 타입 제공하기
* 아이템 50 오버로딩 타입보다는 조건부 타입을 사용하기
* 아이템 51 의존성 분리를 위해 미러 타입을 사용하기
* 아이템 52 테스팅 타입의 함정에 주의하기

7장 코드를 작성하고 실행하기

* 아이템 53 타입스크립트 기능보다는 ECMAScript 기능을 사용하기
* 아이템 54 객체를 순회하는 노하우
* 아이템 55 DOM 계층 구조 이해하기
* 아이템 56 정보를 감추는 목적으로 private 사용하지 않기
* 아이템 57 소스맵을 사용하여 타입스크립트 디버깅하기

8장 타입스크립트로 마이그레이션하기

* 아이템 58 모던 자바스크립트로 작성하기
* 아이템 59 타입스크립트 도입 전에 @ts-check와 JSDoc으로 시험해 보기
* 아이템 60 allowJs로 타입스크립트와 자바스크립트 같이 사용하기
* 아이템 61 의존성 관계에 따라 모듈 단위로 전환하기
* 아이템 62 마이그레이션의 완성을 위해 noImplicitAny 설정하기
