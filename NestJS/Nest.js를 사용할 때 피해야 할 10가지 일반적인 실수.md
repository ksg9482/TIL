1. TypeScript를 사용하지 않는다.

Nest.js는 TypeScript를 기반으로 만들어졌다. JavaScript도 충분히 사용할 수 있지만, TypeScript는 JavaScript의 기능을 그대로 활용할 수 있고 타입으로 인한 오류를 방지하는 JavaScript의 상위집합이다.

TypeScript를 이용하면 보다 안정적인 어플리케이션을 개발 할 수 있고, JavaScript로 컴파일되기 때문에 성능적인 문제에서도 자유롭다.

2. 코드를 제대로 구성하지 않는다.

[모듈식 아키텍처](https://docs.nestjs.com/modules#modules)

Nest.js는 모듈식 아키텍처를 따른다. 모듈식 아키텍처는 Root모듈이 있고, 그 Root모듈에 작은 모듈이 결합한다. 또 작은 모듈에는 세부적인 모듈이 붙는 식으로 작은 모듈을 조합하여 전체적인 어플리케이션을 형성한다.

밀접하게 관련된 기능들을 각각의 모듈로 캡슐화 하여 공급하기 때문에, 거대한 단일 모듈을 사용하면 유지 관리하기 어려워진다.
 
3. DI(의존성 주입)에 올바른 패턴을 사용하지 않는다.

(인젝션 스코프)[https://docs.nestjs.com/fundamentals/injection-scopes]

Nest.js는 DI를 사용하여 프레임워크 내의 구성 요소에 종속성을 제공한다. 의존성 주입이란 하나의 객체가 다른 객체의 의존성을 제공하는 것을 말하고, '주입'은 의존성(서비스)을 사용하려는 객체로 전달하는 것이다. 이는 객체의 생성과 객체의 사용을 분리하는데 목적이 있다.

그러나 주의하지 않으면 낮은 결합도를 유지하지 못해 코드를 유지 보수, 테스트하기 어려워진다. 이를 방지하려면 Singleton 또는 Transient 패턴과 같이 상황에 맞는 올바른 DI 패턴을 사용해야 한다.

* Singleton - 싱글톤 패턴을 뜻한다. 싱글톤 패턴이란 객체의 인스턴스가 오직 한개만 생성되는 패턴이다. Nest.js에서 모듈은 기본적으로 싱글톤 패턴을 사용하여 여러 모듈간에 동일한 공급자 인스턴스를 공유한다.

* Transient - Nest.js에서는 임시 공급자를 뜻한다. 공유되지 않으며, 임시 공급자를 주입하면 각각 새로운 인스턴스를 받는다.

기본적으로 Nest.js는 Singleton을 권장한다. 어플리케이션 시작중에 인스턴스를 캐시할 수 있고 초기화가 한 번만 발생하기 때문이다.

4. 예외 처리를 제대로 하지 않는다.

[예외 필터](https://docs.nestjs.com/exception-filters#exception-filters)

오류 또는 예외가 발생하면 이를 적절하게 처리하고 사용자에게 의미 있는 오류 메시지를 제공하는 것이 중요하다.

Nest.js는 기본적으로 중앙 집중식의 예외처리 모듈을 제공한다. 그리고 예외를 처리하지 않아도 기본으로 제공하는 Exceptions layer에서 예외와 예러를 포착하여 적절한 응답을 자동으로 보낸다. 

비즈니스 로직 계층에서 try-catch 블록을 사용하지 말고 기본으로 제공하는 예외 필터를 사용하여 중앙 집중식의 재사용 가능한 방식으로 예외를 처리하는 편이 좋다.

5. 입력 유효성 검사 파이프를 사용하지 않는다.

[파이프](https://docs.nestjs.com/pipes)

Nest.js의 파이프는 들어오는 데이터를 변환하고 검증할 수 있는 강력한 기능이다. 변환과 검증 두 경우 모두 메소드가 호출되기 전에 컨트롤러에서 작동한다.

수동으로 검사하면 중복 코드로 이어지고 보안이 취약해질 수 있고, 파이프를 사용하면 입력의 유효성을 검사하고 유효한 데이터만 전달 할 수 있다.

6. 인증을 위해 가드를 사용하지 않는다.

[가드](https://docs.nestjs.com/guards)

Nest.js는 여러가지 가드(Guard)를 제공한다. 가드는 경로 및 리소스에 대한 액세스를 제어하는데 사용하며, 무단 액세스로부터 어플리케이션을 보호 할 수 있다. 가드는 단일 책임을 갖는데, 특정 조건에 따라 요청이 지정된 처리기에 따라 처리되는지 여부를 결정한다.

일반적으로 Express의 미들웨어(Middleware)와 같지만 가드는 요청/응답 주기의 정확한 지점에 처리 논리를 삽입하고 선언적으로 그렇게 할 수 있도록 설계할 수 있다.

7. async/await를 제대로 사용하지 않는다.

async/await는 비동기 코드를 더 쉽게 작성할 수 있게 해주는 강력한 기능이다. 그러나 주의하지 않으면 성능 문제와 디버그하기 어려운 오류가 발생할 수 있다.

빡빡한 루프에서 async/await를 사용하지 말고, 오류가 발생하면 적절히 처리하고 적절한 응답을 반환해야 한다.

8. 내장 로거를 사용하지 않는다.

[로거](https://docs.nestjs.com/techniques/logger)

Nest.js는 애플리케이션에 대한 메시지, 오류 및 기타 정보를 기록하는 데 사용할 수 있는 내장 로거를 제공하기 때문에 별도의 로깅 라이브러리를 사용하지 않아도 된다. 물론 가장 나쁜 것은 아무것도 로깅하지 않는 것이다.

로거를 사용하면 어플리케이션에서 발생하는 상황을 추적하고 더 쉽게 문제를 해결 할 수 있다.

Nest.js의 내장 로거는 주로 개발시 시스템 동작을 모니터링하는 데 사용되기 때문에 Winston과 같은 전용 로깅 모듈이 필요할 때도 있다. 이 경우에도 내장 로거를 활용하여 전문적인 로깅 모듈과 결합 할 수 있다.

9. 코드를 테스트하지 않는다. 

[테스트](https://docs.nestjs.com/fundamentals/testing)

코드에 대한 테스트를 작성하여 예상대로 작동하는지 확인하고 버그가 문제가 되기 전에 잡아내는 것이 중요하다. 자동화된 테스트는 개발중 개별 테스트와 전체적인 테스트를 빠르게 반복하여 개발자에게 더 빠른 피드백을 제공할 수 있다.

단위 테스트와 통합 테스트 및 E2E 테스트를 작성하여 애플리케이션을 철저히 테스트하는 것이 좋고, Nest.js는 테스트 구축과 자동화에 도움이 되는 기능들을 제공한다.

10. Nest.js 커뮤니티를 사용하지 않는다.

Nest.js는 활발한 개발자 커뮤니티를 가지고 있다. Github 또는 Discord 에서 연락할 수 있다.

참조
[https://medium.com/@enguerrandpp/10-common-mistakes-to-avoid-when-using-nest-js-ea96f5f460b0](https://medium.com/@enguerrandpp/10-common-mistakes-to-avoid-when-using-nest-js-ea96f5f460b0)
[https://docs.nestjs.com](https://docs.nestjs.com)
(https://ko.wikipedia.org/wiki/의존성_주입)[https://ko.wikipedia.org/wiki/%EC%9D%98%EC%A1%B4%EC%84%B1_%EC%A3%BC%EC%9E%85]