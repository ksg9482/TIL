# 정책과 수준

## 정책
소프트웨어 시스템이란 정책을 기술한 것이고, 대다수의 주요 시스템에서 하나의 정책은 이 정책을 서술하는 여러개의 작은 정책들로 쪼갤 수 있다.
소프트웨어 아키텍처를 개발하는 기술에는 이런 정책을 분리하고 재편성하는 일도 포함된다.

## 수준
수준을 엄밀하게 정의하면 입력과 출력까지의 거리다. 거리가 멀수록 정책의 수준이 높아지고, 가까울수록 정책의 수준은 낮아진다. 입력과 출력을 다루는 정책이라면 시스템에서 최하위 수준에 위치한다.
소스코드 의존성은 그 수준에 따라 결합해야지 데이터 흐름을 결합해선 안된다. 때문에 데이터 흐름과 의존성이 같은 방향을 가리키지 않는 경우도 있다.

고수준의 정책을 저수준의 입/출력에서 분리시키면 입/출력에 변화가 생기더라도 정책은 거의 영향을 받지 않게 된다. 
동일한 시점에 변경되는 정책은 함께 묶이고, 입/출력에서 멀리 있을수록 덜 빈번하게 변경된다. 저수준 정책은 더 빈번하게 변경되고, 긴급성을 요하지만 덜 중요한 이유로 변경되고는 한다.

___

# 업무 규칙
업무 규칙에는 여러가지가 있다. 컴퓨터상으로 구현했는지와 상관없이 사업적으로 수익을 얻거나 비용을 줄일 수 있어야 한다. 이는 사람이 수동으로 시행해도 마찬가지다.   
이러한 업무 규칙을 핵심 업무 규칙이라 부른다. 이 규칙은 사업 자체에 핵심적이며, 규칙을 자동화하는 시스템이 없더라도 업무 규칙은 그대로 존재한다. 핵심 업무 규칙은 보통 데이터를 요구하는데, 이 데이터는 핵심 업무 데이터이다. 이 데이터는 시스템으로 자동화 되어 있지 않은 경우에도 존재한다.   

핵심 업무 규칙과 핵심 업무 데이터는 본질적으로 결합되어 있기 때문에 객체로 만들 좋은 후보가 된다. 이 객체를 엔티티(entity)라고 부른다.

## 엔티티
엔티티는 핵심 업무 데이터를 기반으로 동작하는 일련의 조그만 핵심 업무 규칙을 구체화 한다. 엔티티의 인터페이스는 핵심 업무 데이터를 기반으로 동작하는 핵심 업무 규칙을 구현한 함수로 구성된다.

이러한 종류의 클래스를 생성할 때, 업무에서 핵심적인 개념을 구현하는 개념을 구현하는 소프트웨어는 한데 모으고, 나머지 고려사항과는 분리시킨다. 이 클래스는 업무의 대표자로서 독립적으로 존재하고, 다른 고려사항(데이터베이스, 사용자 인터페이스 등)으로 오염되어선 안된다. 

엔티티의 유일한 요구조건은 핵심 업무 데이터와 핵심 업무 규칙을 하나로 묶어서 별도의 소프트웨어 모듈로 만들어야 한다는 것이다.

## 유스케이스
모든 업무규칙이 엔티티는 아니다. 자동화된 시스템이 동작하는 방법을 정의하고 제약하는 업무 규칙도 있다. 유스케이스란 자동화된 시스템이 사용되는 방법을 말하고, 이런 규칙은 자동화된 시스템의 요소로 존재해야 의미가 있다.   
유스케이스는 엔티티 내부의 핵심 업무 규칙을 어떻게, 그리고 언제 호출할지 명시하는 규칙을 담는다. 엔티티의 작동을 유스케이스가 제어하는 것이다.

유스케이스는 시스템이 사용자에게 어떻게 보이는지가 아니라, 사용자와 엔티티 사이의 상호작용을 규정한다. 시스템에서 데이터가 들어오고 나가는 방식은 유스케이스와 무관하다.

유스케이스는 엔티티에 대해 알고 있지만, 엔티티는 자신을 제어하는 유스케이스에 대해 알지 못한다. 왜냐하면 유스케이스는 단일 어플리케이션에 특화되어 있고, 해당 시스템의 입력과 출력에 보다 가깝게 위치하는 저수준이기 때문이다.
엔티티는 핵심 업무 규칙이 다양한 어플리케이션에서 사용될 수 있도록 일반화된 것이다. 유스케이스는 엔티티에 의존한다.

## 요청 및 응답 모델
유스케이스는 입력 데이터를 받아서 출력 데이터를 생성한다. 제대로된 유스케이스라면 데이터를 주고받는 방식에 대해 눈치챌 수 없어야 한다.   
단순한 요청 데이터 구조를 입력으로 받아들이고, 단순한 응답 데이터 구조를 출력으로 반환한다. 이들 데이터 구조는 HttpRequest나 HttpResponse 같은 표준 프레임워크에서 파생되지 않고, 웹뿐만 아니라 어떤 사용자 구조에도 종속되지 않는다.    
요청 및 응답 모델이 독립적이지 않다면, 그 모델에 의존하는 유스케이스도 결국 해당 모델이 수반하는 의존성에 간접적으로 결합되어 버린다.

엔티티와 응답/요청 모델은 상당히 많은 데이터를 공유하므로 어떤 형태로든 함께 묶으려는 생각이 들 수 있지만 이 두 객체는 완전히 다른 이유로 변경된다. 

## 결론
업무 규칙은 저수준의 관심사로 인해 오염되어서는 안된다. 이상적으로는 업무 규칙을 표현하는 코드는 시스템의 심장부에 위치하고, 덜 중요한 코드는 이 심장부에 플러그인되어야 한다.   

업무 규칙은 가장 독립적이며 가장 많이 재사용 할 수 있어야 한다.

___


# 소리치는 아키텍처
아키텍처는 그 자체로 어플리케이션의 용도를 알려준다. 아키텍처는 곧 그 어플리케이션의 설계도이며, 도서관 설계도를 보면 도서관인 것을 아는 것처럼 아키텍처를 보면 무엇에 대한 설계도인지 알 수 있어야 한다.
소프트웨어 아키텍처는 시스템의 유스케이스를 지원하는 구조이지, 프레임워크에 대한 것이 아니다. 프레임워크로 부터 아키텍처를 제공받아서는 안된다. 

좋은 아키텍처는 유스케이스를 그 중심에 두기 때문에 환경에 구애받지 않고 유스케이스를 지원하는 구조를 기술할 수 있다.

## 웹은 아키텍처인가?
웹은 전달 메커니즘(입출력 장비)일 뿐이다. 어플리케이션 아키텍처에서도 그와 같이 다뤄야 한다. 어플리케이션이 웹을 통해 전달된다는 사실은 세부사항이지, 시스템구조를 지배해서는 안된다.   
시스템 아키텍처는 시스템이 어떻게 전달될지 가능한한 몰라야 한다.

## 유스케이스가 최우선이다.
프레임워크는 매우 강력하고 유용할 수 있다. 하지만 프레임워크를 어떻게 사용할지, 또 비용은 얼마나 드는지를 고려해야 한다. 만약 그 프레임워크를 사용할 수 없다면 어떻게 할 것인가?    
프레임워크가 아키텍처의 중심을 차지하는 상황을 막고, 아키텍처 중심에 유스케이스를 두어야 한다.

아키텍처가 유스케이스를 최우선으로 두고, 또 프레임워크와 적당히 거리를 둔다면 필요한 유스케이스 전부에 대해 단위 테스트를 할 수 있어야 한다.   
테스트를 돌리는데 웹 서버가 반드시 필요하거나, 데이터 베이스가 반드시 연결되어야만 테스트를 돌릴 수 있는 상황이 되어서는 안된다.

## 결론
아키텍처는 시스템을 이야기해야 하며, 적용된 세부사항을 이야기해서는 안된다. 새로 합류한 프로그래머는 시스템이 어떻게 전달될지 모르는 상태에서도 시스템의 모든 유스케이스를 이해 할 수 있어야 한다.

___

# 클린 아키텍처
아키텍처에 관련된 여러 아이디어가 있지만, 그 내용과 목표는 관심사의 분리이다. 소프트웨어를 계층으로 분리하여 관심사 분리를 달성할수 있는데, 각 아키텍처는 최소한 업무 규칙을 위한 계층 하나와 사용자와 시스템 인터페이스를 위한 또다른 계층 하나를 포함한다.
아키텍처는 시스템을 다음과 같은 특징을 지니도록 만든다.
* 프레임워크 독립성 - 아키텍처는 프레임워크의 존재여부에 의존하지 않고, 프레임워크를 도구로 사용할 수 있게 한다.
* 테스트 용이성 - 업무 규칙은 UI, 데이터 베이스 및 그 외의 외부요소 없이도 테스트 할 수 있다.
* UI 독립성 - 시스템의 나머지 부분을 변경하지 않고도 UI를 쉽게 변경할 수 있다.
* 데이터베이스 독립성 - 업무 규칙은 데이터베이스에 결합되지 않기에 데이터베이스를 교체할 수 있다.
* 모든 외부 에이전시에 대한 독립성 - 업무 규칙은 외부 세계와의 인테페이스에 대해 전혀 알지 못한다.

## 클린 아키텍처의 계층
저자가 말하는 클린 아키텍처는 네개의 계층으로 나누어진다. 항상 네개여야 한다는 법칙은 없고 오히려 더 많은 원이 필요할 수도 있다. 하지만 어떤 경우에도 저수준에서 고수준으로 향하는 의존성 규칙은 적용된다.   
* 엔티티
* 유스케이스
* 컨트롤러, 게이트웨이, 프레젠터
* 장치, 웹, UI, DB

고수준의 계층은 저수준의 계층의 어떤 것도 알지 못한다. 고수준에 속한 코드는 저수준에 선언된 그 어떤 이름도 언급해서는 안된다. 이는 함수, 클래스, 변수 등 모든 것을 포함한다.   
같은 이유로 저수준에서 선언된 데이터형식도 고수준에서 절대로 사용해서는 안된다. 특히 그 데이터형식이 저수준의 프레임워크가 생성한 것이면 더더욱 안된다. 저수준에 위치한 어떤 것도 고수준에 영향을 주지 말아야 한다.

### 엔티티
전사적인 핵심 업무규칙을 캡슐화 한다. 엔티티는 메서드를 가지는 객체이거나 일련의 데이터구조와 함수의 집합일 수도 있다.
오부의 무언가가 변경되더라도 엔티티가 변경될 가능성은 낮다. 운영 관점에서 특정 어플리케이션에 무언가 변경이 필요하더라도 엔티티 계층에는 영향을 주어선 안된다.

### 유스케이스
유스케이스 계층의 소프트웨어는 어플리케이션에 특화된 업무 규칙을 포함한다. 유스케이스는 엔티티로 들어오고 나가는 데이터 흐름을 조절하고 엔티티가 자신의 핵심 업무 규칙을 사용해서 유스케이스의 목적을 달성하도록 이끈다.   
이 계층에서 발생한 변경이 엔티티에 영향을 주어선 안되고, 반대로 UI, 데이터베이스 등 저수준의 계층에서 일어난 변화가 이 계층에 영향을 주어서도 안된다.    

유스케이스 계층은 이런 관심사로부터 격리되어 있지만, 운영 관점에서 어플리케이션이 변경된다면 코드 일부는 분명 영향을 받는다.

### 인터페이스 어댑터
어댑터는 데이터를 유스케이스와 엔티티에게 가장 편리한 방식에서 데이터베이스나 웹 등 외부 에이전시에게 편리한 방식으로 변환한다.   
이 계층은, 예를들어 GUI의 MVC 아키텍처를 모두 포괄하고 뷰, 컨트롤러, 프레젠터는 모두 인터페이스 어댑터 계층에 속한다.   

모델은 그저 데이터 구조에 지나지 않으며, 컨트롤러에서 유스케이스로 전달되고 다시 유스케이스에서 프레젠터와 뷰로 되돌아 간다.   
이 계층에 속한 어떤 코드도 데이터베이스에 대해 알아서는 안된다. 예컨테 SQL 기반 데이터베이스를 사용한다면 모든 SQL은 이 계층을 벗어나선 안되고, 특히 이 계층에서도 데이터베이스를 담당하는 부분으로 제한되어야 한다.

또한 이 계층에는 데이터를 외부 서비스와 같은 외부적인 형식에서 유스케이스나 엔티티에서 사용되는 내부적인 형식으로 변환하는 또다른 어댑터가 필요하다.

### 프레임워크와 드라이버
가장 저수준의 계층은 일반적으로 데이터베이스나 웹 프레임워크 같은 도구들로 구성된다. 이 계층 세부사항이 위치하는 곳이다.    
웹이나 데이터베이스 같은 세부사항은 모두 외부에 위치시켜서 피해를 최소화 한다.

## 경계 횡단하기
제어흐름과 의존성이 명백히 반대여야 하는 경우 대체로 의존성 역전 원칙을 사용하여 해결한다.    
만약 유스케이스에서 프레젠터를 호출해야 하는 경우를 가정하자. 이 때, 직접 호출하면 의존성 규칙을 위배한다.   
유스케이스가 같은 계층의 인터페이스(유스케이스 출력포트)를 호출하도록 하고 저수준의 프레젠터가 그 인터페이스를 구현하도록 만들어야 한다.   

경계를 횡단하는 데이터는 흔히 간단한 데이터 구조로 이루어져 있다. 기본적인 구조체, 데이터 전송 객체(DTO)등이다. 중요한 점은 격리되어있는 간단한 데이터 구조가 경계를 가로질러 전달된다는 사실이다.
만약 데이터구조가 어떤 의존성을 갖는다면 의존성 규칙을 위배하게 된다.  따라서 경계를 가로질러 데이터를 전달 할 때, 데이터는 항상 대상이 되는 계층에서 사용하기 편리한 형태를 가져야 한다.

## 결론
수많은 고통거리를 덜어내는 방법은 간단한 규칙들을 준수하는 것이다. 소프트웨어를 계층으로 분리하고 의존성 규칙을 준수하면 테스트하기 쉬운 시스템을 만들수 있고, 데이터베이스나 웹 프레임워크를 교체하더라도 보다 쉽고 안정적으로 교체할 수 있다.
