# 2부 - 벽돌부터 시작하기: 프로그래밍 패러다임
## 패러다임 개요
프로그래밍 패러다임이란 프로그래밍을 하는 방법을 말하며 대체로 언어에 독립적이다.
패러다임은 어떤 프로그래밍 구조를 사용할지, 언제 이 구조를 사용할지 결정한다.

## 각 프로그래밍 패러다임에 대하여
각 패러다임은 프로그래머에게서 권한을 박탈한다. 어느 패러다임도 새로운 권한을 부여하지 않는다. 
즉, 패러다임은 무엇을 해선 안되는지를 말하며 이를 통해 '규칙'을 부과한다.

___
## 구조적 프로그래밍
* 구조적 프로그래밍은 최초로 적용된 패러다임이다. 
* 무분별한 점프(goto)는 프로그램 구조에 해롭다는 사실을 제시하고 이를 if/then/else와 do/while/until 등의 구조로 대체했다.
* 즉, 구조적 프로그래밍은 제어흐름의 직접적인 전환에 대해 규칙을 부과한다.

### 구조적 프로그래밍의 탄생
에츠허르 비버 데이크스트라라는 사람이 있다. 그는 네덜란드 최초의 프로그래머였고, 프로그래밍의 원리나 과학을 수학적으로 증명하려 했다.   
   
### goto문의 해로움
데이크스트라는 프로그래밍은 어렵고, 프로그래머는 프로그래밍을 잘하지 못한다는 문제를 인식했다.   
모든 프로그램은 단순해도 인간의 두뇌로 감당하기에는 너무 많은 세부사항을 담고 있었다. 아주 작은 세부사항이라도 간과하면 프로그램은 실패하곤 했다.   
   
그는 **증명**이라는 수학적인 원리를 적용하여 이 문제를 해결하고자 했다.    
프로그래머는 입증된 구조를 이용하고 이 구조를 코드와 결합시키며, 그래서 코드가 **올바르다**는 사실을 스스로 증명하게 되는 방식이었다. 
   
이 연구를 진행하면서 goto 문장이 모듈을 더 작은 단위로 재귀적으로 분해하는 과정에 방해가 되는 경우가 있다는 사실을 발견했다.   
만약 모듈을 분해 할 수 없다면 분할 정복 접근법을 사용 할 수 없게 된다.   
반대로 goto문을 사용하더라도 모듈을 분해할 때 방해가 되지 않는 경우도 있었다.   
이 경우는 'if/then/else'와 'do/while'과 같은 분기와 반복이라는 단순한 **제어구조**에 해당함을 발견했다.   
   
이런 발견은 곧, 모듈을 증명가능하게 만드는 제어구조가 모든 프로그램을 만들 수 있는 제어구조의 최소 집합과 동일하다는 사실의 발견이었고, 그 최소 집합이란 각각 <b>순차(sequence), 분기(selection), 반복(iteration)</b>이었다.   
  
맨처음 goto문의 해로움과 세가지 제어구조(순차, 분기, 반복)에 대해 발표했을 때, 프로그래밍 세계는 많은 논쟁이 일어났으나 결국 데이크스트라가 옳았다는 결론이 내려졌다.   
컴퓨터 언어가 진화하면서 goto문은 계속 뒤로 밀려났고, 현재 대부분의 현대적인 언어는 goto문을 포함하지 않게된 것이다.   
심지어 goto문을 여전히 지원하는 언어에서도 goto문의 목적지 범위를 현재 함수 안으로 한정시키는 편이다.   
   
### 기능적 분해
구조적 프로그래밍을 통해 모듈을 증명 가능한 더 작은 단위로 분해할 수 있다는 뜻은, 결국 모든 모듈을 기능적으로 분해할 수 있음을 뜻한다.   
문제를 고수준의 기능들로 분해하고 다시 저수준의 함수들로 분해하면, 분해한 기능들은 구조적 프로그래밍의 제한된 제어구조를 이용하여 표현 할 수 있다.   

이런 기법을 사용하면 프로그래머는 대규모 시스템을 모듈과 컴포넌트로 나눌 수 있고, 더 나아가 모듈과 컴포넌트는 입증할 수 있는 작은 기능들로 세분화 할 수 있다.   
   
### 테스트
프로그램 관점에서 수학적으로 증명된 구조는 결국 만들어지지 않았다. 그러나 무언가가 올바른지 입증할 때 사용하는 전략은 엄밀한 수학적 증명만이 있는 것이 아니다.   
프로그램에 도입된 것은 과학적 방법이었고, 과학은 근본적으로 수학과 달랐다.   

* 실험을 아무리 많이 수행해도 다른 실험을 통해 법칙이 잘못되었음이 밝혀질 가능성이 있다. 즉, 과학은 반증은 가능하나 증명은 불가능하다.   
* 과학은 서술된 내용이 틀렸음을 증명하는 방식으로 동작하고, 반례를 들 수 없는 서술이 있다면 목표에 부합할 만큼은 참이라고 본다.   

이런 과학적 방법처럼, 프로그램이 잘못되었다는 테스트를 작성하고 그 테스트들을 통과하는 일은 프로그램이 목표에 부합할 만큼은 충분히 참이라고 여길 수 있게 해준다.   
   
### 구조적 프로그래밍의 결론
구조적 프로그래밍은 프로그램을 증명 가능한 세부 기능 집합으로 분해 할 것을 강요한다.   
그리고 테스트를 통해 분해한 기능들이 거짓인지 증명하려고 시도하고, 시도들이 실패하면 이 기능들은 목표에 부합할 만큼은 충분히 참이라고 여긴다.   
   
구조적 프로그래밍이 오늘날에도 가치를 갖는 이유는 프로그래밍에서 **반증 가능한 단위**를 만들어 낼 수 있는 이런 능력 때문이다.   
뿐만아니라 아키텍처 관점에서는 기능적 분해를 최고의 실천법 중 하나로 여기는 이유이기도 하다.   

___
## 객체지향 프로그래밍
* 객체지향 프로그래밍은 구조적 프로그래밍 보다 2년 앞서 등장했다. 
* 알골 언어(ALGOL)의 함수 호출 스택 프레임(stack frame)을 힙(heap)으로 옮기면 함수 호출이 반환된 이후에도 함수에서 선언된 지역변수가 오랫동안 유지됨을 발견했다. 
* 이런 함수는 클래스의 생성자가 되었고, 지역변수는 인스턴스 변수, 중첩 함수는 메서드가 되었다. 
* 함수 포인터를 특정 규칙에 따라 사용하는 것에 따라 자연스럽게 다형성이 등장하게 되었다.
* 즉, 객체지향 프로그래밍은 제어흐름의 간접적인 전환에 대해 규칙을 부과한다.

좋은 아키텍처를 만드는 일은 객체지향 설계 원칙을 이해하고 응용하는 데서 출발한다. 그렇다면 객체지향이란 무엇인가?
* 대체적으로 데이터와 함수의 조합이라 설명되지만 만족스러운 대답은 아니다. 객체지향 프로그래밍이 발명되기 전부터 프로그래머는 데이터 구조를 함수에 전달해 왔다.
* 실제 세계를 모델링하여 프로그램을 더 쉽게 이해하기 위한 방법? 이 말이 무슨 의미인지, 왜 이 방향을 추구해야 하는지 불분명하다.
* 캡슐화, 상속, 다형성 이 세가지 개념도 객체지향을 확실하게 설명해주지 않는다.

### 캡슐화
객체지향을 정의하는 요소중 하나로 캡슐화를 언급하는 이유는, 데이터와 함수를 쉽고 효과적으로 캡슐화하는 방법을 객체지향 언어가 제공하기 때문이다.   
그리고 이를 통해 데이터와 함수가 높은 응집도로 구성된 집단을 서로 **구분**지을 수 있다.   
이 구분선 바깥에서 데이터는 은닉되고, 일부 함수만이 외부에 노출된다. 이 것들은 각각 클래스의 private 멤버 데이터와 public 멤버 함수로 표현된다.   

그런데 이런 캡슐화의 개념이 객체지향에만 국한된 것은 아니다. 다른 언어에서도 접근할 수 있는 함수와, 접근할 수 없는 데이터나 함수를 나눠서 외부에서 모르게 할 수 있다.   
그리고 사실 많은 객체지향 언어가 캡슐화를 강제하지 않고, 언어의 기술적인 이유나 구현방법으로 인해 캡슐화가 약화된 면도 있다.   

따라서 객체지향은 강력한 캡슐화에 의존한다는 정의는 받아들이기 힘들다. 

### 상속 
상속이란 어떤 변수와 함수를 하나의 유효범위로 묶어서 **재정의** 하는 일이다. 하지만 예전부터 프로그래머는 객체지향 언어의 도움 없이 이런 방법을 구현 할 수 있었다.
물론 객체지향 프로그래밍으로 고안된 상속을 이용하는 것보다 불편하긴 했다. 

상속을 흉내내는 요령은 있었지만 상속만큼 편리한 방법은 아니었고, 이 기법을 이용해서 다중 상속을 구현하는 것은 훨씬 더 어려운 일이었다.   
따라서 객체지향 언어가 완전히 새로운 개념을 만들지는 못했지만 데이터구조에 가면을 씌우는 일을 상당히 편리하게 만들어주었다고 할 수 있다.

### 다형성
객체지향 언어가 있기 전에 다형성을 지원했는가? 답은 '그렇다'이다. 다형성은 함수를 가리키는 포인터를 응용한 것이다.   
객체지향의 다형성은 이전에 없던 다형성이란 개념을 제공해주는 것이 아니라, 다형성을 좀 더 **안전하고 편리하게** 사용할 수 있게 해주는 것이다.

즉, 함수에 대한 포인터를 직접 사용하는 일의 관례 일부를 망각하면 버그가 발생하고 이렇게 발생한 버그는 찾기도 고치기도 힘들다.   
객체지향 언어는 이런 관례를 없애주어서 실수하지 않도록 해준다. 

#### 의존성
전형적인 호출트리를 생각해보면 main함수가 고수준 함수를, 고수준 함수가 중간수준 함수를, 중간수준 함수는 다시 저수준 함수를 호출한다.
이런 호출트리에서는 소스코드 의존성의 방향은 제어흐름을 따른다. 

하지만 다형성이 끼어들면 상황이 바뀐다. 다형성이 끼어들면 소스코드의 의존성이 제어흐름과 반대가 될 수 있다.   
이는 다형성을 안전하고 편리하게 제공한다면 소스코드의 의존성을 어디에서든 역전 시킬 수 있다는 뜻이다.

즉, 프로그래머는 호출하는 모듈이든 호출받는 모듈이든 관계없이 소스코드 의존성을 원하는 방향으로 설정 할 수 있다.

다형성은 컴포넌트를 개별적이며 독립적으로 배포할 수 있게 해준다.   
특정 컴포넌트의 소스코드가 변경되면 해당 코드가 포함된 컴포넌트만 재배포 하면 된다. 이것이 **배포 독립성**이다.   
시스템의 모듈을 독립적으로 배포 할 수 있게 되면, 서로 다른 팀에서 각 모듈을 독립적으로 개발 할 수 있게 된다. 이것이 **개발 독립성**이다.


### 객체지향 프로그래밍의 결론
소프트웨어 아키텍처의 관점에서 객체지향이란 무엇인가에 대한 답변을 내리자면, 다형성을 이용하여 소스코드 의존성에 대한 제어 권한을 획득할 수 있는 능력이다.   

객체지향을 사용하면 고수준의 정책을 포함하는 모듈은 저수준의 모듈에 대해 독립적일 수 있다.   
마찬가지로 저수준의 세부사항을 포함하는 모듈도 독립적으로 개발하고 배포 할 수 있다.

___
## 함수형 프로그래밍
* 함수형 프로그래밍은 사실 가장 먼저, 컴퓨터 프로그래밍 자체보다 먼저 등장했다. 
* 어떤 수학적 문제를 해결하는 과정에서 람다 계산법이 발명되었고, 함수형 프로그래밍은 이 람다 계산법에 영향을 받아 만들어졌다. 
* 람다 계산식의 근간은 불변성(immutablity)으로 심볼(symbol)의 값이 변경되지 않는다는 개념이다. 
* 이는 함수형 언어에는 할당문이 없다는 뜻이며 가능한 경우에도 까다로운 조건 아래에서만 가능하다.
* 즉, 함수형 프로그래밍은 할당문에 대해 규칙을 부과한다.
 
### 불변성
함수형 언어에서 변수는 변경되지 않는다. 변수는 초기화 되면 변하지 않기 때문에, 함수형 언어에는 가변 변수가 없다.
이것이 함수형 언어의 가장 큰 특징인 불변성이다.

가령 반복문을 사용할 경우 자바나 자바스크립트는 이런 식,
```javascript
//JavaScript
for(let i = 0; i < 25; i ++;) {
	console.log(i)
}
```
이와 같이 변수 'i'가 변한다.

#### 불변성과 아키텍처
아키텍처를 고려 할 때 왜 이런 내용(변수의 가변성)이 중요할까?   
왜냐하면 경합 조건, 교착상태 조건, 동시 업데이트 등의 문제가 전부 가변 변수가 원인으로 발생하기 때문이다.   

스레드와 프로세스가 여러개인 상황에서도 설계한 시스템이 안정적일 수 있을까? 불변성이 실행 가능할까?
답변은 대체로 긍정적이다. 단, 저장공간과 프로세서의 한계가 없다면 말이다. 

한계가 있다면 일종의 타협을 해야한다.

#### 가변성의 분리
불변성과 관련해 가장 주요한 타협점 중 하나는 어플리케이션 또는 어플리케이션의 내부를 가변 컴포넌트와 불변 컴포넌트로 분리하는 것이다.    

* 불변 컴포넌트에서는 순수하게 함수형 방식으로만 작업을 처리한다.    
* 상태 변경은 컴포넌트를 갖가지 동시성 문제에 노출하는 일이므로 가변 변수도 보호해야 한다.      

가능한 많은 처리를 불변 컴포넌트로 옮겨야 하고, 가변 컴포넌트에서는 가능한 많은 코드를 빼내야 한다.   

### 이벤트 소싱
저장 공간과 처리 능력의 한계는 급격히 늘어난다. 즉, 저장공간이나 처리능력으로 인해 필요한 가변상태는 더욱 적어진다는 뜻이다.   
   
은행 어플리케이션을 예로 들어보자. 고객의 계좌 잔고를 변경할 때, 잔고를 변경하는 것이 아니라 트랙잭션 자체를 저장한다면?   
잔고 조회를 요청할 때마다 계좌 개설 시점부터 발생한 모든 트랜잭션을 단순히 더한다면, 이 전략에선 가변 변수가 필요 없다.   
   
물론 이런 접근법은 터무니 없다. 그러나 이 전략을 영원히 유지할 필요는 없다.   
어플리케이션의 수명주기 동안만 문제 없이 동작할 저장공간과 처리능력이 있으면 충분하기 때문이다.   
이벤트 소싱에 깔려있는 기본 발상이 바로 이것이다.   
   
상태가 필요해지면 단순히 상태의 시작점부터 모든 트랜잭션을 처리한다.   
   
지름길을 택한다면, 매일 자정에 상태를 계산한 후 값을 저장하고 상태가 필요하면 자정 이후의 트랜잭션만을 처리하면 된다.

#### 어디에 쓰이는가?
데이터 저장소에 쓰인다. 저장 공간이 많이 필요하지만, 이미 저장 공간은 급속도로 커지고 있다.   
이 전략(데이터의 CRUD중 CR만 사용)을 사용하면 저장소에 수정과 삭제가 발생하지 않으니 동시 업데이트 문제도 발생하지 않는다.   
저장공간과 처리능력이 충분하다면 어플리케이션이 완전한 불변성을 갖도록 할 수 있고, 완전한 함수형으로 만들 수 있다.
   
예를 들자면 소스 코드 버전 관리 시스템이 정확히 이 방식으로 동작한다.   

### 함수형 프로그래밍의 결론
함수형 프로그래밍은 변수 할당에 규칙을 부과한다.   

___
## 프로그래밍 패러다임과 아키텍처의 관계
우리는 아키텍처 경계를 넘나들기 위해 다형성을 이용한다.   
함수형 프로그래밍을 이용하여 데이터의 위치와 접근법에 대해 규칙을 부과한다.   
그리고 모듈 기반의 알고리즘으로 구조적 프로그래밍을 사용한다.   

세 가지 패러다임과 아키텍처의 큰 관심사 세가지(함수, 컴포넌트 분리, 데이터 관리)가 어떻게 연관되는지가 중요하다.
