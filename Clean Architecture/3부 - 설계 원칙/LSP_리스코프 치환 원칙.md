# LSP_리스코프 치환 원칙
## LSP(Liskov Substitution Principle) 개요
바바라 리스코프(Babara Liskov)는 하위타입을 다음과 같이 정의했다.
* S타입의 객체 O1에 각각 대응하는 T타입의 객체 O2가 있다.
* T타입을 이용하여 정의한 모든 프로그램 P에서 O2의 자리에 O1을 치환했다.
* 이 때, P의 행위가 변하지 않는다면 S는 T의 하위 타입이다.

### 정사각형 / 직사각형 문제
리스코프 치환 원칙을 위반하는 전형적인 문제로는 정사각형 / 직사각형 문제가 있다.

이 예제에서 정사각형은 직사각형의 하위타입으로 적합하지 않은데, 직사각형의 높이와 너비는 독립적으로 변경될 수 있는 반면, 정사각형의 높이와 너비는 반드시 함께 변경되기 때문이다.

이런 형태의 리스코프 치환 원칙 위반을 막기 위해선 (⁭if문 등을 이용해서) 직사각형이 실제로는 정사각형인지 검사하는 메커니즘을 클래스 혹은 메서드에 추가해야 한다.

그러나 이렇게 하면 **행위가 사용하는 타입에 의존**하게 되므로 결국 타입을 서로 치환 할 수 없게 된다.

### 리스코프 치환 원칙과 아키텍처
객체지향이 등장한 초창기에는 리스코프 치환 원칙이 상속을 사용하도록 가이드하는 방법으로 간주되었다.

하지만 시간이 지나며 이 원칙은 인터페이스와 구현체에도 적용되는 더 **광범위한 소프트웨어 설계 원칙**으로 변모했다.

여기서 말하는 인터페이스는 다양한 형태로 나타난다. 

자바같은 언어라면 인터페이스 하나와 이를 구현하는 여러 클래스로 구성되고, 루비라면 동일한 메서드 시그니처를 공유하는 여러개의 클래스로 구성된다.

또는 동일한 REST 인터페이스에 응답하는 서비스 집단일 수 있다.

이 상황 말고도 더 많은 경우에도 리스코프 치환 원칙을 적용 할 수 있다.

### 결론
리스코프 치환 원칙은 **아키텍처 수준까지 확장**할 수 있고, 반드시 확장해야 한다. 

치환 가능성을 위배하면 시스템 아키텍처가 오염되어 상당량의 별도 메커니즘을 추가해야 할 수도 있기 때문이다.
