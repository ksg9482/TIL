# ISP_인터페이스 분리 원칙
## ISP(Interface Segregation Principle) 개요
인터페이스 분리 원칙은 다음과 같은 상황에서 그 이름이 유래되었다.

* OPS라는 클래스가 있고, 이 클래스에는 op1, op2, op3라는 오퍼레이션이 있다.
* User1은 op1만을 사용하고, User2은 op2만을 사용한다. 마찬가지로 User3은 op3만을 사용한다고 하자.
* OPS가 정적 타입 언어로 작성된 클래스라고 한다면  User1에서는 op2, op3을 전혀 사용하지 않음에도 User1의 소스코드는 이 두 메서드에 의존하게 된다.
* 이런 의존성으로 인해 OPS 클래스에서 op2의 소스코드가 변경되면, User1과 관련된 코드가 변경되지 않았으나 User1도 다시 컴파일하고 새로 배포해야 한다. 

이런 문제는 오퍼레이션을 인터페이스 단위로 분리하여 해결 할 수 있다.

### 인터페이스 분리 원칙과 언어
앞의 사례는 언어타입에 의존한다. 정적 타입 언어는 사용자가 import, use, include와 같은 타입 선언문을 사용하도록 강제한다.

이처럼 소스코드에 포함된(included) 선언문으로 인해 소스코드 의존성이 발생하고, 이로 인해 재컴파일과 재배포가 강제되는 상황이 무조건 초래된다.

루비나 파이썬 같은 동적 타입 언어에서는 소스코드에 이러한 선언문이 존재하지 않는다. 대신 런타임에 추론이 발생한다.

따라서 소스 코드 의존성이 아예 없으며, 결국 재컴파일과 재배포가 필요없다.

 * 물론 이 부분은 깊게 들어가면 복잡해진다.

동적 타입 언어를 사용하면 정적 타입 언어를 사용할 때 보다 유연하며 결합도가 낮은 시스템을 만들 수 있는 이유는 이 때문이다.

이러한 사실로 인해 인터페이스 분리 원칙을 아키텍처가 아니라, **언어와 관련된 문제라고 결론내릴 여지**가 있다.

### 인터페이스 분리 원칙과 아키텍처
한 걸음 물러서서 이 원칙을 사용하는 근본적인 동기를 살펴보면, 잠재된 더 깊은 우려사항을 볼 수 있다.

일반적으로, 필요 이상으로 많은 걸 포함하는 모듈에 의존하는 것은 해로운 일이다. 소스코드 의존성의 경우 이는 분명한 사실인데, 불필요한 재컴파일과 재배포를 강제하기 때문이다.

심지어 더 고수준인 아키텍처에서도 마찬가지인 상황이 발생 할 수 있다.

* S시스템을 구축하기 위해 F라는 프레임워크를 도입하기로 했다.
* F프레임워크는 특정한 D데이터베이스를 사용해야 한다.
* 따라서 S는 F에 의존하고, 다시 F는 D에 의존하는 구조가 되었다.
* 이 때 F에서는 불필요한 기능, 따라서 S와는 전혀 관계없는 불필요한 기능이 D에 포함된다고 하자.
* D내부에서 그 기능에 대한 변경이 발생하면 F를 재배포 해야 할 수도 있고, S까지 재배포 해야 할지 모른다.
* 심각한 경우를 생각해 본다면, D내부에서 F와 S에서 불필요한 기능에 문제가 발생해도 F와 S에 영향을 주는 경우가 있을 수 있다.



### 결론
**불필요한 짐**을 실은 무언가에 의존하면 예상치 못한 문제에 빠지기 쉽다. 

이에 대한 것은 이후 '컴포넌트 응집도'에서 공통 재사용 원칙을 논할 때 더 자세히 다룰 것이다.
