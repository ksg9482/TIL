# SRP_단일 책임 원칙
## SRP(Single Responsibility Principle) 개요

SOLID 원칙 중 의미가 가장 잘 전달되지 못한 원칙이 바로 단일 책임 원칙이다. 

아마 프로그래머가 이 원칙을 듣는다면 모듈은 단 하나의 일만 해야한다는 의미로 받아들이기 쉽다.

하지만 단 하나의 일만 해야한다는 원칙은 따로 있다. 바로 **'함수는 단 하나의 일만 해야 한다'**는 원칙이다. 

단일 책임 원칙은 역사적으로 '단일 모듈은 변경의 이유가 하나뿐이여야 한다'를 말해 왔다.

변경의 이유는 사용자와 이해관계자들 즉, 변경을 요구하는 사람 혹은 집단을 가리킨다.

이 사람들을 '액터'라고 부른다면 단일 책임 원칙은 아래의 의미를 갖게 된다.
* 하나의 모듈은 오직 **하나의 액터**에 대해서만 책임져야 한다. 

모듈은 일반적으로 소스코드를 가리킨다. 더 정확히 말하자면 함수와 데이터구조로 구성된 응집된 집합이다.

응집된(cohesive)이라는 단어가 단일 책임 원칙을 암시한다. 단일 액터를 책임지는 코드를 함께 묶어주는 힘이 바로 응집성(cohesion)이다.

이 원칙을 이해하는 가장 좋은 방법은 원칙을 위반하는 징후들을 살펴보는 것이다.

### 징후 1. 우발적 중복
```javascript
class Employee {
	calculatePay();
	reportHours();
	save();
}
```
Employee라는 클래스가 있다고 하자. 이 클래스는 3가지 메서드를 가진다.
* calculatePay() - 회계팀에서 정의하고 CFO 보고를 위해 사용한다. 
* reportHours() - 인사팀에서 정의하고 COO 보고를 위해 사용한다.
* save()  - 데이터 베이스 관리자가 기능을 정리하고 CTO보고를 위해 사용한다.

이 경우 Employee 클래스는 단일 책임 원칙을 위반 했다. 세가지 메서드가 서로 다른 세 액터를 책임지기 때문이다.

세 메서드가 단일 클래스에 배치되었으므로, 이 결합으로 인해 CFO 팀에서 결정한 조치가 COO팀이 의존하는 무언가에 영향을 줄 수 있다.

예를 들어보자.

* 초과 근무를 제외한 업무 시간을 계산하기 위해 regularHours() 라는 메서드를 만들었다.
  * 이 메서드는  급여계산을 위해 calculatePay()메서드와, 업무시간 계산을 위해 reportHours()메서드가 공유한다.
  * 그런데 CFO팀에서 업무시간 계산 방식을 수정하기로 결정했고 COO팀은 업무시간을 다른 목적으로 사용하기에 수정을 원치 않는다.  
  * 이 업무를 할당받은 개발자는 regularHours() 메서드를 수정하기 전 calculatePay()에서 해당 메서드가 호출된다는 사실은 눈치챘지만 reportHours()에서도 호출된다는 사실은 눈치채지 못했다.
  * 수정된 regularHours() 메서드는 배포되었고 COO팀은 수정 사실을 모른채 calculatePay()로 생성한 보고서를 이용했다.
  * 하지만 메서드의 변경으로 인해 이 보고서에 포함된 수치들은 엉망이다.

이런 상황은 서로 다른 액터가 의존하는 코드를 너무 가까이 배치해서 발생한다. 

그렇기에 SRP는 **서로 다른 액터가 의존하는 코드는 서로 분리하라**고 말한다.

즉, 중복된 것처럼 보여도 변경을 요청할 수 있는 액터가 하나가 아니라면 사실은 중복된게 아니다. 합치지 말고 분리해야 한다.


### 징후2. 병합
소스파일에 많은 메서드를 포함하면 병합이 자주 발생한다. 특히 메서드가 서로 다른 액터를 책임진다면 병합이 발생할 가능성이 확실히 더 높다.

가령 서로 다른 팀에 속한 두명의 개발자가, Employee 클래스에 변경사항을 적용한다고 하자. 

이 변경으로 인해 공통된 메서드는 각각 다른 방식으로 수정되었고, 결과적으로 이 변경사항들은 서로 충돌하여 병합이 발생했다. 

병합에 위험이 따른다는 것은 말하지 않아도 알 것이다. 어떠한 도구를 사용하여 병합을 해결할 수 있지만 모든 경우를 해결할 수는 없다.

살펴볼만한 징후가 더 있겠지만 이 징후들은 모두 많은 사람이 서로 다른 목적으로 동일한 소스 파일을 변경하는 경우에 해당한다.

다시한번 말하지만, 이 문제를 해결하는 방법은 **서로 다른 액터를 뒷바침하는 코드를 서로 분리**하는 것이다.

### 해결책
문제의 해결책은 다양하지만 그 모두가 결국 메서드를 각기 다른 클래스로 이동시키는 방식이다. 

아마 가장 확실한 해결책은 데이터와 메서드를 분리하는 방식일 것이다. 

예를 들자면, 아무런 메서드가 없는 데이터 구조인 EmployeeData 클래스를 만들어 세개의 클래스가 공유하도록 한다.

세 클래스는 서로의 존재를 몰라야 한다. 때문에 우연한 중복을 피할 수 있다.
```javascript
class EmployeeData {};

class PayCalculator extends EmployeeData 
	calculatePay()
};

class HourReporter extends EmployeeData {
	reportHours()
};

class EmployeeSaver extends EmployeeData {
	saveEmployee()
};
```

이 해결책은 개발자가 세 클래스를 인스턴스화 하고 추적해야 한다는 것이 단점이다. 이 경우 흔히 쓰는 기법으로 파사드 패턴이 있다.

파사드 클래스를 두어 이 클래스는 세 클래스의 객체를 생성하고, 요청된 메서드를 가지는 객체로 위임하는 일을 책임진다.

또는 가장 중요한 메서드는 기존의 Employee 클래스에 유지하되 Employee 클래스를 덜 중요한 나머지 메서드들에 대한 파사드로 사용할 수 도 있다.

모든 클래스는 단 하나의 메서드를 가져야 한다는 주장에 근거하여 앞의 해결책에 반대할 수 있지만, 이 주장은 현실과 다르다.

각 클래스에 기능을 구현하기 위한 메서드의 개수는 훨씬 많아서 클래스는 다수의 private 메서드를 포함할 것이다.

이렇게 여러 메서드가 하나의 유효범위를 이루면 해당 유효범위 바깥에서는 감춰진 멤버(private)가 있는지 알 수 없다.

### 결론
단일 책임 원칙은 메서드와 클래스 수준의 원칙이다. 하지만 더 상위 수준에서도 다른 형태로 등장한다. 

컴포넌트 수준에서는 공동 폐쇄 원칙(Common Closure Principle)이 되고, 아키텍처 수준에서는 아키텍처 경계의 생성을 책임지는 변경의 축(Axis of Change)가 된다.
