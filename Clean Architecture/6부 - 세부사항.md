# 데이터베이스는 세부사항이다
아키텍처 관점에서 보면 데이터베이스(데이터 모델이 아니라 데이터베이스 자체)는 세부사항이다. 데이터베이스는 데이터에 접근할 방법을 제공하는 유틸리티일 뿐이다. 유틸리티는 저수준의 세부사항일 뿐이라 아키텍처와는 관련이 없다.

### 관계형 데이터베이스
관계형 데이터베이스는 데이터를 저장하고 접근하는데 탁월한 기술이다. 그러나 기술은 기술일 뿐이다. 관계형 테이블은 특정한 형식의 데이터에 접근하는 경우에는 편리하지만, 데이터를 테이블에 행 단위로 배치한다는 것은 아키텍처적으로 볼 때 전혀 중요하지 않다.   

어플리케이션의 유스케이스는 이러한 방식을 알아서는 안된다. 데이터가 테이블구조를 가진다는 사실은 오직 아키텍처의 바깥쪽에 위치한 최하위 수준의 유틸리티 함수만 알아야 한다. 

테이블과 행이 객체 형태로 시스템 여기저기에서 돌아다니게 허용하는 것은 잘못된 설계다. 이렇게 하면 유스케이스, 업무 규칙, 심지어 UI조차도 관계형 데이터 구조에 결합되어 버린다.

### 데이터베이스 시스템은 왜 널리 사용되는가?
디스크는 데이터 저장소의 중심에 위치해 있었다. 하지만 느리다는 특성이 발목을 잡았다. 작업에는 밀리초 단위의 시간이 필요했고, 이는 다른 프로세서와 비교하면 극도로 느린 것이었다.

시간지연을 완화하기 위해 색인, 캐시, 쿼리 최적화가 필요해졌고, 데이터를 표현하는 일종의 표준적인 양식도 필요했다. 시간이 지나서 이러한 시스템은 파일시스템과, 관계형 데이터베이스 관리 시스템 두 가지 유형으로 분리되었다.

파일시스템은 문서(document) 기반이다. 일련의 문서를 이름을 기준으로 저장하거나 조회할 때는 잘 동작하지만, 내용을 기준으로 검색할 때는 그리 크게 도움이 되지 않는다.

데이터베이스는 내용 기반이다. 내용을 기준으로 찾는 방법을 제공하고, 레코드가 서로 공유하는 일부 내용에 기반해서 다수의 레코드를 연관짓는데 탁월하다. 하지만 정형화되지 않은 문서를 저장하고 검색하는데는 대체로 부적합하다.

두 시스템은 데이터를 체계화해서 각 시스템에 특화된 방식으로 접근할 때 효율적으로 데이터를 저장하고 검색할 수 있다. 그러나 결국에는 관련있는 데이터를 RAM으로 가져온다.

만약 디스크가 사라지고 그 자리를 RAM이 차지하게 된다면, 데이터를 파일구조로 만들어 저장할 것인가 아니면 테이블구조로 저장할 것인가?

오히려 연결리스트, 트리, 해시테이블 등 무수히 많은 데이터구조로 체계화 할 것이다.

곰곰히 생각해보면 이미 파일이나 데이터베이스에서 데이터를 RAM으로 불러온 후에는 목적에 맞추어 데이터구조를 변경한다. 데이터를 파일이나 테이블 형태로 그대로 두는 경우는 거의 없다.

### 데이터베이스가 세부사항인 이유
데이터베이스가 세부사항이라고 말하는 이유는 이러한 현실 때문이다. 데이터베이스는 그저 메커니즘에 불과하고, 데이터를 장기적으로 저장하는 공간에 지나지 않는다. 

따라서 아키텍처적인 관점에서 본다면 데이터가 어떤 형태로 저장되는지 신경써서는 안된다. 심지어 디스크를 비롯한 저장소가 존재한다는 사실조차 인식해서도 안된다.

물론 성능은 아키텍처적인 관심사이긴 하다. 그러나 데이터 저장소의 성능은 완전히 캡슐화하여 업무 규칙과는 분리할 수 있는 관심사다. 

이 관심사는 저수준의 데이터 접근 메커니즘 단에서 다루는 것으로, 시스템의 전반적인 아키텍처와는 관련이 없다.

### 결론
체계화된 데이터 구조와 데이터 모델은 아키텍처적으로 중요하다. 반면, 그저 데이터를 데이터를 옮길뿐일 기술과 시스템은 아키텍처적으로 중요하지 않다.

데이터는 중요하지만 데이터베이스 시스템은 세부사항이다. 



___


# 웹은 세부사항이다
웹은 사실 아무것도 바꾸지 않았다. 소프트웨어 업계는 1960년대 이래로 반복되는 진동을 겪었고, 웹은 그저 이러한 진동의 맨 끝에 있을 뿐이다. 이 진동은 모든 연산 능력을 중앙 서버에 두는 방식과 모든 연산 능력을 단말에 두는 방식 사이에서 끊임없이 움직여 왔다.

처음에는 모든 연산 능력이 서버 팜(server farm)에 위치할 것이라 생각했다. 이윽고 브라우저에 애플릿(applet)을 추가하기 시작하다가 동적인 내용은 다시 서버로 이동시켰다.

그러다가 웹2.0을 고안했고, Ajax와 자바스크립트를 이용해서 처리과정의 많은 부분을 브라우저로 옮겼다. 이제는 또 노드(Node.js)를 이용해 자바스크립트는 다시 서버로 옮기고 있다.

### 끝없이 반복하는 추
이처럼 반복되는 진동은 웹으로부터 시작된 것이 아니다. 웹이 있기 전에 클라이언트 - 서버 아키텍처가 있었고, 그 전에는 수많은 단말기가 연결되는 중앙집중식 미니컴퓨터가 있었다.

또 그 전에는 단말기가 연결되는 메인프레임이 있었으며, 그 전에는 컴퓨터실과 천공카드가 있었다. 

그리고 이 이야기는 계속된다. 연산 능력을 중앙에 집중하는 방식과 분산하는 방식 사이에서 끊임없이 움직일 뿐이고 한동안 계속될 것이다.

IT 역사 전체로 시야를 넓히면 웹은 우리가 발버둥치며 생기는 수많은 진동중 하나에 불과하다. 이 진동은 핵심 업무규칙의 중심에서 밀어내야 할 문제일 뿐이다.

### 요약
GUI는 세부사항이고 웹은 GUI이다. 따라서 세부사항은 핵심 업무로직에서 분리해야 한다. 

웹을 입출력장치라 생각해 보자, 어플리케이션을 장치 독립적으로 만들어야 한다는 규칙은 웹도 예외가 될 수는 없다.

물론 웹과 같은 GUI는 너무 특이하고 다채로워서 장치 독립적인 아키텍처를 추구하기 힘들 수 있다. 어플리케이션과 웹과 같은 GUI의 상호작용은 빈번하며, 또 상호작용 방식도 사용중인 GUI에 따라 차이가 매우 크다.

하지만 UI와 어플리케이션 사이에는 추상화가 가능한 경계가 존재한다. 업무 로직은 다수의 유스케이스로 구성되고, 각 유스케이스는 사용자를 대신하여 일부 함수를 수행하는 것이다. 그렇다면 유스케이스는 입력 데이터, 수행할 처리과정, 출력데이터를 기반으로 기술 할 수 있다.

입력데이터와 그에 따른 출력데이터는 데이터구조로 만들어서 유스케이스를 실행하는 처리과정의 입력값과 출력값으로 사용할 수 있다. 이 방식을 사용하면 각 유스케이스가 장치 독립적인 방식으로 UI라는 입출력 장치를 동작시킨다고 간주 할 수 있다.


___

# 프레임워크는 세부사항이다. 
프레임워크는 강력하다. 하지만 프레임워크는 아키텍처가 될 수 없다.

프레임워크를 사용해야 할 경우 우리는 프레임워크 제작자가 제공하는 문서를 꼼꼼히 읽고, 만드려는 소프트웨어와 프레임워크를 통합하려 한다.

대개의 경우 프레임워크를 중심에 두고 만들려는 아키텍처가 바깥에 위치하게 된다. 또한 프레임워크의 기반 클래스에서 직접 파생하거나, 프레임워크의 기능들을 업무 객체에 직접 임포트해서 사용한다.

이렇게 되면 아키텍처는 프레임워크와 강하게 결합된다. 프레임워크를 사용해서 발생하는 위험과 부담은 오로지 사용자가 감수할 뿐, 제작자는 감수하지 않는다.

### 위험 요인
프레임워크를 사용할 때, 이러한 위험요인들이 있다.

* 프레임워크의 아키텍처는 깔끔하지 않은 경우가 많다. 의존성 규칙을 위반하는 경향이 있고, 업무 객체를 만들때 프레임워크의 코드를 상속해야 한다. 심지어 고유한 엔티티를 만들 때조차 말이다. 
프레임워크가 아키텍처의 중심과 결합하면 다시 바깥쪽으로 빼내기 어렵다.

* 프레임워크는 어플리케이션의 초기 기능을 만드는 데 도움이 되지만, 제품이 성숙해지면 프레임워크가 제공하는 기능과 틀을 벗어나게 된다. 나중에는 오히려 프레임워크와 싸우는 모습을 발견하게 될지도 모른다.

* 프레임워크는 원하지 않는 방향으로 진화할 수도 있다. 도움이 되지 않는 신규 버전으로 업그레이드하느라 다른 일을 못할 수도 있고, 사용중이던 기능이 사라지거나 변형될 수도 있다.

* 더 나은 프레임워크가 등장하면 갈아타고 싶어질 수 있다.

### 해결책
프레임워크를 사용하되, 결합해서는 안된다. 프레임워크는 아키텍처의 바깥쪽에 위치한 세부사항으로 취급하고, 안쪽으로 들어오지 못하게 해야한다.

업무 객체를 만들때 프레임워크의 기반 클래스로부터 파생해야 한다면, 대신 프락시(proxy)를 만들고 업무규칙에 플러그인 할 수 있는 컴포넌트에 이들 프락시를 위치시켜라.

프레임워크가 핵심 코드 안으로 들어오지 못하게 하고, 핵심코드에 플러그인 할 수 있는 컴포넌트에 프레임워크를 통합하고 의존성 규칙을 준수하라.

### 결론
사용하는 프로그래밍 언어에 따라 거의 반드시 사용해야 하는 프레임워크도 있다. 
이 관계는 피하기 힘들다. 하지만 프레임워크를 사용한다면 어플리케이션의 생애 동안 그 프레임워크와 항상 함께해야 한다는 사실을 잊으면 안된다. 결코 가볍게 생각해서는 않된다.

