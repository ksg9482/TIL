# 5부 - 아키텍처 part.1

## 개요
형편없는 아키텍처를 갖춘 시스템은 많고, 그런 시스템도 나름대로 잘 돌아간다. 그렇다면 아키텍처를 갖추어야 하는 이유는 무엇일까?
형편없는 아키텍처는 운영에서는 괜찮아도 배포, 유지보수, 계속되는 개발 과정에서 어려움을 겪기 때문이다.

아키텍처의 주된 목적은 시스템의 생명주기를 지원하는 것이다. 쉽게 이해하고, 쉽게 개발하고, 쉽게 유지보수할 수 있게 하며, 쉽게 배포할 수 있게 해준다.
즉, 아키텍처의 궁극적인 목표는 시스템의 수명과 관련된 비용은 최소화하고, 프로그래머의 생산성은 극대화 하는 것에 있다.

### 개발
개발하기 힘든 시스템이라면 수명이 길지도 않고 건강하지도 않다.   

팀구조가 다르면 아키텍처 관련 결정도 차이가 난다. 팀이 작다면 아키텍처 관련 제약들이 방해만 된다 느낄 수 있으나, 여러팀이 동원될 정도로 거대한 규모라면 아키텍처 설정 없이 진척되지 않는다.
아키텍처에 신경쓰지 않으면 아키텍처 없이 개발을 진행하거나 컨포넌트 구조는 편한대로 만들어지기 쉽고, 이런식으로 만들어진 컴포넌트가 최적일 가능성은 거의 없다.

### 배포 
배포 비용이 높을수록 시스템의 유용성은 떨어진다. 개발 초기 단계에서는 배포 전략을 거의 고려하지 않기 때문에 배포하기 어려운 소프트웨어가 만들어지기 쉽다.
따라서 아키텍처는 시스템을 한 번에 쉽게 배포할 수 있도록 만드는데 그 목표를 두어야 한다. 

### 운영
비록 개발, 배포, 유지보수를 중요시하는 경우가 많지만, 좋은 소프트웨어 아키텍처는 시스템을 운영하는데 필요한 요구도 알려준다.    
유스케이스, 기능, 시스템의 필수 행위를 일급(first-class) 엔티티로 격상시켜, 이들 요소가 개발자에게 주요 목표로 인식되도록 해야한다.   
이를 통해 시스템을 이해하기 쉬워지고, 개발과 유지보수에 도움을 줄 수 있다.

* 유스케이스 - 액터(행위자)와 액터가 요구하여 시스템이 수행하는 일의 목표.

### 유지보수
비용이 가장 많이 발생하는 부분이다. 기능추가, 결함수정 등 시간과 인적자원이 소모된다.   

유지보수에서 가장 큰 비용은 탐사(spelunking)와 이로 인한 위험부담에 있다. 탐사란 새로운 기능을 추가하거나 결함을 수정할 때 소프트웨어의 어디를 고치는게 최선일지, 어떤 전략이 최선일지 결정할 때 드는 비용이다.
변경사항을 반영할 때 의도치 않은 결함이 발생할 가능성도 존재하기에, 그에 따른 위험부담 비용이 추가된다.
신중하게 아키텍처를 만들면 이 비용을 크게 줄일 수 있다. 시스템을 컴포넌트로 분리하고 안정된 인터페이스를 두어 서로 격리 하는 것이다.
이렇게 하면 쉽게 기능추가를 할 수 있고, 의도하지 않은 장애가 발생할 위험을 줄일 수 있다.

### 선택사항 열어두기
소프트웨어를 부드럽게 유지하는 방법은 선택사항을 가능한 많이, 가능한 오랫동안 열어두는 것이다.    
선택사항은 바로 세부사항(detail)이다. 모든 소프트웨어는 정책(policy)과 세부사항으로 나누어진다.   
   
정책 요소는 모든 업무 규칙과 업무 절차를 구체화 한다. 세부사항은 입출력장치, 데이터베이스, 프레임워크 등이다.
아키텍트의 목표는 시스템에서 정책을 가장 핵심적인 요소로 식별하고, 세부사항은 정책에 무관하게 만들 수 있는 형태의 시스템을 구축하는 것이다.

### 결론
좋은 아키텍트는 세부사항과 정책을 신중히 가려내고, 서로 결합하지 않도록 엄격히 분리한다.   
이를 통해 정책은 세부사항을 알지 못하게 되고, 세부사항에 의존하지 않게 된다.


## 독립성
좋은 아키텍처는 시스템의 유스케이스, 운영, 개발, 배포를 지원한다. 

### 유스케이스
유스케이스를 지원한다는 것은 곧, 시스템의 의도를 지원해야 한다는 뜻이다. 하지만 아키텍처는 시스템의 행위에 그다지 큰 영향을 주지 않는다. 그런데 어떻게 지원한다는 것일까?   
행위를 명확히 하고 외부로 드러내며, 이를 통해 시스템이 지닌 의도를 아키텍처 수준에서 알아볼 수 있게 만드는 것이다.

만약 좋은 아키텍처를 지닌 장바구니 어플리케이션이라면, 이 어플리케이션은 장바구니처럼 보일 것이고 해당 시스템의 유스케이스는 시스템의 구조 자체에서 한눈에 드러날 것이다.
이들의 행위는 일급 요소이며 시스템의 최상위에서 알아볼 수 있고 자신의 기능을 분명히 설명하는 이름을 가질 것이다.

### 계층 결합 분리
아키텍트는 필요한 모든 유스케이스를 지원하기 원하지만 유스케이스 전부를 알지는 못한다. 하지만 시스템의 기본적인 의도는 분명히 알고 있기 때문에 의도와 맥락에 따라 분리하고 묶는다.   
이때 사용하는 원칙이 바로 단일 책임 원칙과 공통 폐쇄 원칙이다. 다른 이유로 변경되는 것을 분리하고 같은 이유로 변경되는 것을 묶는다.

업무 규칙은 그 자체가 어플리케이션에 밀접한 관련이 있거나 혹은 더 범용적일 수 있다.   

예를 들어 입력 필드 유효성 검사는 어플리케이션 자체와 관련된 업무 규칙이다. 반대로 재고품 집계는 업무 도메인에 관련된 업무 규칙이다.
이들은 서로 다른 속도로 또 서로 다른 이유로 변경되기 때문에 분리하고, 독립적으로 변경될 수 있도록 만들어야 한다.

이런 식으로 시스템을 서로 결합되지 않은 수평적인 계층으로 분리해야 한다. 이런 계층의 예로는 UI, 데이터베이스, 어플리케이션과 독립된 업무규칙, 반대로 어플리케이션에 특화된 업무규칙 등이 있다.

그리고 유스케이스 그 자체도 서로 다른 이유로 변경 될 수 있다. 각 유스케이스는 시스템의 수평적인 계층을 가로지는 수직적인 좁은 영역이기도 하다.
주문입력 시스템에서 주문을 추가하는 유스케이스와 주문을 삭제하는 유스케이스는 서로 다른 속도로 또 서로 다른 이유로 변경된다.
즉, 유스케이스는 시스템을 분할하는 자연스러운 방법이기도 하다. 같은 UI 계층 이라도 주문 추가와 주문 삭제로 구분하는 식으로 유스케이스가 시스템의 각 계층에서 서로 겹치지 않게 해야 한다.

유스케이스를 뒷받침하는 UI, 데이터베이스 등을 묶어서 각각 서로 다른 관점(aspect)을 사용하게 하면 새로운 유스케이스를 추가하더라도 기존 유스케이스에 영향을 주는 일을 최소화 할 수 있다.

### 결합 분리와 운영
유스케이스에서 서로 다른 관점이 분리되었다면 높은 처리량을 보장하는 유스케이스와 낮은 처리량으로도 충분한 유스케이스는 이미 분리되어 있을 가능성이 높다.
유스케이스를 위해 수행하는 그 작업들은 운영에도 도움이 된다. 하지만 운영 측면에서 이점을 살리려면 결합을 분리할 때 적절한 모드를 선택해야 한다.

분리된 컴포넌트를 서로 다른 서버에서 실행해야 하는 상황이라면, 단일 프로세서의 동일한 주소공간에 함께 상주하는 형태로 만들어선 안된다.   
분리된 컴포넌트는 독립된 서비스가 되어야 하고 일종의 네트워크를 통해 통신해야 한다.

보통 이런 컴포넌트를 서비스 또는 마이크로서비스라고 부른다. 하지만 그 구분기준은 모호한 면이 있다. 실제로 서비스에 기반한 아키텍처를 서비스 지향 아키텍처라고 부른다.

### 개발 독립성과 배포 독립성
컴포넌트가 분리되면 팀 사이의 간섭은 줄어든다. 어떤 형태의 팀이라도 계층과 유스케이스의 결합이 분리되는 한 시스템의 아키텍처는 그 팀 구조를 뒷바침해준다.   
또 유스케이스와 계층의 결합이 분리되면 배포 측면에서도 고도의 유연성이 생긴다. 제대로 분리했다면 운영중인 시스템에서도 계층과 유스케이스를 교체 할 수 있다.

#### 중복
계층과 유스케이스로 결합을 분리하면 중복처럼 보이는 요소가 발생하기도 한다. 이 때, 진짜 중복인지 아니면 우발적 중복(가짜 중복)인지 살펴보아야 한다.
일반적으로 소프트웨어에서 중복은 나쁜 것이다. 그러나 우발적 중복은 비슷해 보여도 서로 다른 경로가 코드가 발전해가면서 코드가 달라진다.

유스케이스를 수직으로 분리할 때나 계층을 수평으로 분리할 때 이런 문제(서로 비슷한 구조, 서로 비슷한 알고리즘)를 마주친다.   
우발적 중복을 통합해버리면 나중에 다시 분리 하느라 수고를 감수하게 된다. 비슷한 구조라도 영역이 다르다면 분리된 구조를 유지하는 것이 계층간 결합을 적절하게 유지하는데 도움을 준다.


### 결합을 분리하는 방법
* 소스 수준 분리 모드
  * 소스 코드 모듈 사이의 의존성을 제어 할 수 있다. 이 모드에선 모든 컴포넌트가 같은 주소상에서 실행되고 통신은 함수호출을 이용한다. 컴퓨터 메모리에는 하나의 실행파일이 로드되며 이를 흔히 모노리틱 구조라고 부른다.
* 배포 수준 분리 모드
  * 배포 가능한 단위들 사이의 의존성을 제어 할 수 있다. 한 모듈의 변경이 다른 모듈에 영향을 미치는 것을 막을 수 있고 많은 컴포넌트가 같은 주소 공간에 상주한다. 통신은 함수호출을 이용하거나 다른 프로세스(동일한 프로세서의)에 위치한 컴포넌트의 경우 소켓, 프로세스 간 통신, 공유 메모리 등을 이용한다.
  * 이 모드의 중요한 특징은 분리된 컴포넌트가 독립적으로 배포할 수 있는 단위로 분할되어 있다는 점이다.
* 서비스 수준 분리 모드
  * 의존하는 수준을 데이터 구조 단위까지 낮출 수 있고 통신은 네트워크 패킷을 통해서만 가능하도록 만들 수 있다. 이를 통해 모든 실행 가능한 단위는 소스와 바이너리 변경에 대해 서로 완전히 독립적이게 된다.(예, 서비스 또는 마이크로서비스)

저자가 선호하는 방식은 컴포넌트 결합을 분리하되 서비스가 되기 직전에 멈추는 방식이다. 이 방식을 사용하면 초기에는 컴포넌트가 소스 코드 수준에서 분리되고 점점 서비스 방향으로 시스템을 변경해간다.
서비스 수준은 비용이 많이 들고 결국 결합이 큰 단위에서 분리된다는 문제가 있다. 특히 노력이 많이 필요하다.

물론 이렇게 하기에는 까다롭고, 시스템의 결합 분리 모드는 시간이 지나면서 바뀌기 때문에 변경을 예측하여 큰 무리없이 반영할 수 있도록 만들어야 한다.

## 경계: 선긋기
소프트웨어 아키텍처는 선을 긋는 기술이다. 경계는 소프트웨어 요소를 서로 분리하고 경계 한 편에 있는 요소들이 경계 반대편에 무엇이 있는지 알지 못하도록 만든다.
이런 선 일부는 프로젝트 아주 초기에, 심지어 코드 작성 전에 그어지기도 한다. 이 선은 어떠한 결정이 핵심적인 업무로직을 오염시키지 못하도록 막는 목적이다. 인적자원의 효율성을 떨어뜨리는 요인은 너무 일찍 내려진 결정에 의한 결합이다.

이른 결정이라는 것은 시스템의 업무 요구사항 즉, 유스케이스와 관련이 없는 결정이다. 프레임워크, 데이터베이스, 의존성 주입등이 여기 포함된다.

좋은 시스템 아키텍처는 이런 결정을 가능한 최후의 순간에 내릴 수 있게 만들어주고, 결정에 따른 영향이 크지 않게 만들어 준다.

### 어떻게 선을 긋는가?

관련이 없는 것과 있는 것 사이에 선을 긋는다. GUI는 업무규칙과 상관이 없기에, 이 둘 사이엔 선이 있어야 한다. 데이터베이스와 GUI는 서로 관련이 없기에 마찬가지로 선이 있어야 한다.

데이터베이스에 관련해서는 동의하지 않는 사람이 있지만, 데이터베이스는 업무 규칙이 간접적으로 사용할 수 있는 도구다. 업무 규칙은 스키마, 쿼리문, 데이터베이스의 세부사항에 대해 알아서는 안된다.   
업무규칙이 알아야 할 것은 사용할 수 있는 함수 집합이 있다는 사실이고, 이런 함수집합을 통해 데이터베이스를 인터페이스의 뒤로 숨길 수 있다.

소프트웨어 아키텍처에서 경계선을 그리려면 먼저 시스템을 컴포넌트 단위로 분할해야 한다. 일부 컴포넌트는 핵심 업무 규칙에 해당하고, 나머지 컴포넌트는 핵심업무와 직접적인 관련이 없지만 필수기능을 포함한다.   
그런 다음 컴포넌트 간 의존성의 방향이 핵심업무를 향하도록 컴포넌트의 소스를 배치한다. 이는 곧, 의존성 역전 원칙과 안정된 추상화 원칙을 응용한 것이다. 의존성은 저수준의 세부사항에서 고수준의 추상화를 향한다.

### 경계 횡단하기
그저 경계 한쪽에 있는 기능에서 반대편 기능을 호출해 데이터를 전달하는 일에 불과하다. 하지만 적절한 위치에서 경계를 횡단하려면 소스코드 의존성 관리가 필요하다.   
경계는 소스코드 모듈 하나가 변경되면 다른 쪽으로 변경이 전파되는 것을 막아준다.

### 단일체
아키텍처 경계중 가장 단순하며 또 흔한 형태는 엄격하게 구분되지 않는 형태다. 이 형태에서는 함수와 데이터가 그저 나름의 규칙에 따라 분리되어 있을 뿐이다. 보통 이런 경우를 소스 수준 분리 모드라고 볼 수 있다.   
배포 관점에서 보면 단일체는 경계가 드러나지 않는다. 그렇다고 경계가 무의미하거나 실제로 존재하지 않는다는 의미가 아니다. 

이런 아키텍처는 거의 모든 경우에 특정한 동적 다형성에 의존하여 내부 의존성을 관리하기 때문에, 객체지향이 중요한 패러다임이 될 수 있었다. 객체지향이 없었다면 결합도를 적절히 분리하기 위한 시도로 포인터를 사용해야 했을 것이고, 너무 위험하기에 컴포넌트를 분리하려는 시도를 포기했을 것이다.

단일체 구조라도 규칙적인 방법으로 구조를 분리하면 프로젝트를 개발, 테스트, 배포하는데 큰 도움이 된다. 

단일체는 통신이 전형적인 함수호출에 지나지 않기 때문에 결과적으로, 소스 코드 수준에서 결합이 분리되면 경계를 가로지는 통신은 상당히 빈번해 질 수 있다.
