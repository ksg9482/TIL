# 개요
대규모 소프트웨어 시스템은 작은 컴포넌트들로 이루어진다. SOLID원칙이 벽과 방에 벽돌을 배치하는 방법이라면, 컴포넌트 원칙은 작은 빌딩에 방을 배치하는 방법이다.

## 컴포넌트
컴포넌트는 시스템의 구성요소로 배포할 수 있는 가장 작은 배포 단위이다.   
컴파일형 언어에서 컴포넌트는 바이너리 파일의 결합체이고, 인터프리터형 언어에서 컴포넌트는 소스파일의 결합체이다.

여러 컴포넌트를 서로 링크하여 실행 가능한 단일 파일로 생성하거나, '.jar' 혹은 '.dll' 등 동적으로 로드할 수 있는 플러그인이나 '.exe' 파일로 만들어 독립적으로 배포 할 수 있다.   

컴포넌트가 어떤 형태로 배포되든 잘 설계된 컴포넌트라면 반드시 독립적으로 배포 가능해야 한다. 따라서 독립적으로 개발 가능한 능력을 갖추어야 한다.

### 컴포넌트의 간략한 역사
* 소프트웨어 개발 초창기에는 메모리에서의 프로그램 위치와 레이아웃을 프로그래머가 직접 제어했다. 
이 시절에는 프로그램 위치가 한번 결정되면 재배치가 불가능 했고, 프로그램은 어플리케이션 코드에 라이브러리 코드가 포함된 단일 파일로 컴파일 되었다.
  * 함수 라이브러리가 클수록 컴파일은 더 오래 걸렸기 때문에 결국 함수 라이브러리와 소스코드를 분리했다. 
그러나 어플리케이션 크기가 커져서 할당된 메모리 공간을 초과하면 라이브러리의 메모리 공간 뒤쪽을 더 할당 받아 어플리케이션을 두개로 분리하여 넣었다. 
라이브러리의 크기가 커지면 마찬가지로 라이브러리도 분리해야 했기 때문에 단편화 문제는 여전했다.
* 이 문제는 재배치가 가능한 바이너리(relocatable binary)로 해결했는데, 지능적인 로더를 사용해서 메모리를 재배치 할 수 있는 형태의 바이너리를 생성하도록 컴파일러를 수정하는 것이다.
  * 프로그래머는 함수 라이브러리와 어플리케이션을 로드할 위치를 로더에게 지시하고, 로더는 여러개의 바이너리를 입력 받은 후 하나씩 메모리로 로드하며 재배치하는 작업을 처리했다.
* 링킹 로더(linking loader - 프로그램을 로드하는 동시에 링크까지 수행하는 로더)의 등장으로 프로그램을 개별적으로 컴파일하고 로드할 수 있는 단위로 분할 할 수 있게 되었으나, 프로그램이 커질수록 링킹 로더는 느리게 느껴지게 되었다.
  * 링킹 로더가 결국 둘로 나뉘어(링커와 로더) 링크 과정은 별도의 어플리케이션으로 수행하게 되었다. 하지마 프로그램 자체의 크기가 커지니 전체 소요시간은 또다시 늘어났다.
  * 1980년대 후반, 하드웨어의 발달(더 작아지고 빨라진 디스크, 더 저렴해진 메모리)로 로드와 링크 속도가 문제가 되지 않을 상황이 되었다.
* 오늘날에는 '.jar', '.dll', 공유 라이브러리등을 어플리케이션에 플러그인 형태로 배포하는 것이 일상적인 일이 되었다.
* 런타임에 플러그인 형태로 결합할 수 있는 동적 링크 파일이 이 책에서 말하는 소프트웨어 컴포넌트에 해당한다. 

## 컴포넌트 응집도
어떤 클래스를 어떤 컴포넌트에 포함시켜야 하는가는 중요한 결정이므로 소프트웨어 엔지니어링 원칙의 도움을 받아야 한다.
하지만 안타깝게도 수년동안 거의 상황에 따른 임시방편으로 결정을 내려왔다.

이 장에서 논의할 컴포넌트 응집도에 관련된 원칙은 세가지이다.

### REP (Reuse / Release Equivalence Principle - 재사용 / 릴리스 등가 원칙)
객체 지향 모델의 오랜 약속 중 하나는 소프트웨어 재사용이다. 돌이켜보면 재사용 / 릴리스 등가 원칙은 당연해 보인다.   

소프트웨어 컴포넌트가 릴리스 절차를 통해 추적 관리되지 않거나 릴리스 번호가 부여되지 않는다면 컴포넌트를 재사용하고 싶어도 할 수 없다. 릴리스 번호가 없다면 재사용 컴포넌트들이 서로 호환되는지 보장할 방법이 없고, 새로운 버전이 언제 출시되고 무엇이 변했는지 알 수 없기 때문이다.
새로운 릴리스가 나온다는 소식을 접한 개발자는 새 릴리스의 변경사항을 보고 기존 버전을 계속 사용할지 여부를 결정한다. 따라서 적절한 공지, 릴리스 문서 작성도 포함되어야 한다.

이 원칙을 아키텍처 관점에서 보면 단일 컴포넌트는, 구성하는 모든 모듈이 서로 공유하는 중요한 테마나 목적이 있어야 함을 뜻한다. 단일 컴포넌트는 응집성 높은 클래스와 모듈들로 구성되어야 한다.   

당연하지만 색다른 시각으로 볼 수도 있다. 하나의 컴포넌트로 묶인 클래스와 모듈은 반드시 함께 릴리스 할 수 있어야 한다. 하나의 컴포넌트로 묶인 클래스와 모듈은 버전 번호가 같고, 동일한 릴리스로 추적 관리되며, 동일한 릴리스 문서에 포함되어야 한다.
이 조언만으로는 클래스와 모듈을 하나의 컴포넌트에 제대로 묶는 방법을 설명하기 힘들다. 그러나 이 원칙을 어기면 '이치에 맞지 않게'되므로 쉽게 발견할 수 있다. 

이런 약점, 제대로 설명하기 힘들다는 점은 다음에 다룰 두 원칙 CCP, CRP가 지닌 강점을 통해 보완 할 수 있다.

### CCP (Common Closure Principle - 공통 폐쇄 원칙)
동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라. 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하는 원칙이다.   

이 원칙은 SRP를 컴포넌트 관점에서 다시 설명한 것이다. SRP가 단일 클래스는 변경의 이유가 하나여야 한다고 말하는 것처럼, CCP는 단일 컴포넌트도 변경의 이유가 하나여야 한다.

대다수의 경우 어플리케이션의 유지보수성(maintainability)은 재사용성보다 훨씬 중요하다. 코드가 반드시 변경되어야 한다면 변경이 여러 컴포넌트에 걸쳐 일어나는 것보다, 단일 컴포넌트에 국한되는 편이 낫다.
변경을 단일 컴포넌트로 제한 할 수 있다면 해당 컴포넌트만 재배포 하면 된다. 

물리적 또는 개념적으로 강하게 결합되어 함께 변경되어야 하는 클래스들은 하나의 컴포넌트에 속하게 하는 것으로, 소프트웨어 릴리스, 재검증, 재배포하는 일의 작업량을 최소화 할 수 있다.

이 원칙은 OCP(개방-폐쇄 원칙)과도 관련이 있다. CCP에서 말하는 폐쇄는 OCP에서 말하는 폐쇄와 같은 의미(Closure)이다.   
100% 완전한 폐쇄는 불가능하므로 전략적으로 폐쇄해야 하고, 발생 가능성이 있거나 과거에 발생한 적이 있는 공통적인 변경에 대해서 클래스가 닫혀있도록 설계해야 한다.

따라서 CCP란 SRP와 OCP에서 얻은 교훈을 컴포넌트 단위에 확대 적용한 셈이다. 결합력이 강한 클래스나 모듈을 하나로 모으면, 변경이 필요한 요구사항이 발생했을 때 그 변경에 영향을 받는 컴포넌트가 최소한으로 한정될 가능성이 높아진다.

### CRP (Common Reuse Principle - 공통 재사용 원칙)
같이 재사용되는 경향이 있는 클래스와 모듈들은 같은 컴포넌트에 포함해야 한다.   
개별 클래스가 단독으로 재사용되는 경우는 거의 없다. 대체로 재사용 가능한 클래스는 재사용 모듈의 일부로써 다른 클래스와 상호작용 하는 경우가 많다.   
이런 식으로 컴포넌트 내부에 클래스들 사이에는 수많은 의존성이 있음을 예상 할 수 있으며 CRP는 이런 클래스들은 동일한 컴포넌트에 포함되어야 한다고 말한다.

CRP가 각 컴포넌트에 어떤 클래스를 포함시켜야 하는지 설명해주는 것처럼, 동일한 컴포넌트로 묶어선 안되는 클래스가 무엇인지도 알려준다.   
어떤 컴포넌트가 다른 컴포넌트를 사용하면 두 컴포넌트 사이에는 의존성이 생겨나고 아주 조금 사용한다고 해서 그 의존성이 약해지지도 않는다. 사용하는 컴포넌트는 사용되는 컴포넌트에 여전히 의존한다.   
이런 의존성으로 인해 사용되는 컴포넌트가 변경될 때마다 사용하는 컴포넌트도 변경해야 할 가능성이 높다. 심지어 사용되는 컴포넌트의 변경이 사용하는 컴포넌트와 전혀 관련이 없더라도 말이다.

따라서 의존하는 컴포넌트가 있다면 해당 컴포넌트의 모든 클래스에 대해 의존함을 확실히 인지해야 한다.   
한 컴포넌트에 속한 클래스들은 더 작게 그룹지을 수 없고, 그 중 일부 클래스에만 의존하고 다른 클래스와는 독립적일 수 없다.   

따라서 CRP는 어떤 클래스를 하나로 묶어서는 안되는지 더 많은 것을 이야기한다.
그 이야기의 결론은 강하게 결합되지 않은 클래스들을 동일한 컴포넌트에 위치시켜선 않된다는 것이다.

#### ISP와의 관계
ISP(인터페이스 분리 원칙)는 사용하지 않는 메서드가 있는 클래스에 의존하지 말라고 조언한다.   
마찬가지로 CRP는 사용하지 않는 클래스를 가진 컴포넌트에 의존하지 말라고 조언한다.   
CRP는 ISP의 포괄적인 버전이며 필요하지 않은 것에 의존하지 말라고 여전히 말하고 있다.

### 세 원칙에 대한 균형
응집도에 관한 세 원칙은 서로 상충하는 모습을 보인다. 
REP(재사용 / 릴리스 등가 원칙)와 CCP(공통 폐쇄 원칙)는 포함 원칙이고, 컴포넌트를 더욱 크게 만든다.   
CRP(공통 재사용 원칙)는 배제 원칙이고, 컴포넌트를 더욱 작게 만든다.

이 원칙들이 균형을 이루는 방법을 찾아야 한다. 이 균형은 개발팀이 현재 관심을 갖는 부분을 충족시켜야 하는데, 시간이 지나면 관심을 갖는 부분 역시 변한다.

예를 들자면 프로젝트 초기에는 CCP가 REP보다 중요하다. 개발 가능성이 재사용성보다 중요하기 때문이다. 프로젝트가 성숙하게 되면 점차 CCP에서 REP로 중요도가 옮겨 간다.
즉, 프로그램의 컴포넌트 구조는 시간과 성숙도에 따라 변하며 프로젝트가 발전되고 사용되는 방법과 관련이 깊다.

오로지 REP와 CRP에만 중점을 두면, 사소한 변경이 생겼을 때 너무 많은 컴포넌트에 영향을 준다.   
반대로 CCP와 REP에만 중점을 두면, 불필요한 릴리스가 너무 빈번해진다.

응집도 원칙은 다음과 같은 상관관계가 있다.
* (CCP-CRP) - 유지보수성과 컴포넌트 분리에 중점을 두었으나, 재사용이 어렵다.
* (REP-CCP) - 재사용성과 유지보수에 중점을 두었으나, 불필요한 릴리스가 빈번해진다.
* (CRP-REP) - 컴포넌트를 분리와 재사용성에 중점을 두었으나, 컴포넌트 변경이 빈번해진다.

### 결론
과거에는 응집도를 '모듈은 단 하나의 기능만 수행해야 한다'는 속성 정도로 이해한 적도 있었다. 하지만 응집도에 대한 세가지 원칙은 응집도가 가질 수 있는 훨씬 복잡한 다양성을 알려준다.   
클래스들을 묶어서 컴포넌트를 만들 때, 재사용성과 개발가능성은 상충하는 힘이라는 점을 고려해서 어플리케이션의 요구에 맞게 균형을 잡아야 한다.
이 균형점은 항상 유동적이므로 상황에 맞춰 잘 분배했어도 시간이 흐르면 맞지 않을 수 있다. 시간의 흐름에 따라 프로젝트의 초점도 개발 가능성에서 재사용성으로 바뀌기 때문에 컴포넌트를 구성하는 방식도 변화한다.

## 컴포넌트 결합
지금부터 다룰 세가지 원칙은 컴포넌트 사이의 관계를 설명한다.   

### ADP (Acyclic Dependencies Principle - 의존성 비순환 원칙)
컴포넌트 의존성 그래프에 순환(cycle)이 있어선 안된다.

많은 개발자가 동일한 소스파일을 수정하는 환경이라면 누군가가 의존하고 있던 무언가를 다른 사람이 수정하는 일이 수시로 일어난다.   
소수의 개발자로 구성된 상대적으로 작은 프로젝트라면 그다지 큰 문제가 되지 않지만, 규모가 큰 프로젝트라면 코드가 작동하도록 수정하고 그 다음날 다시 수정하며 몇날며칠을 보낼 수 있는 문제가 된다.   

이 문제에 대한 해결책으로 두가지 방법이 발전되어 왔는데 바로 주단위 빌드와 의존성 비순환 원칙이다.

#### 주단위 빌드(Weekly Build)
주단위 빌드는 중간 규모 프로젝트에서 흔하게 사용된다. 일주일의 첫 4일은 코드를 복사해 개인적으로 작업하며 금요일이 되면 통합해서 빌드한다.   
그러나 프로젝트가 커지면 통합을 금요일 하루만에 마치는 것은 불가능해지고 효율성은 낮아진다.   
통합과 테스트를 수행하기 어려워 질 뿐더러, 팀은 빠른 피드백이 주는 장점을 잃는다.

#### 순환 의존성 제거하기
개발 환경을 릴리스 가능한 컴포넌트 단위로 분리하여 컴포넌트를 개별 개발자 또는 단일 개발팀이 책임질 수 있는 작업단위로 만든다.
개발자는 해당 컴포넌트가 동작하도록 만든 후 릴리스하여 다른 개발자가 사용할 수 있도록 한다. 다른 개발자는 새로 릴리스된 컴포넌트를 언제 적용할지 정하고 적용할 준비가 되었을 때 적용한다.   
이 방식은 팀이 다른 팀에 의해 좌우되지 않는다. 특정 컴포넌트가 다른 팀에 즉각적인 영향을 주지 않고, 통합은 작고 점진적으로 이뤄진다.

이 같은 작업 절차는 단순하고 합리적이여서 널리 사용되는 방식이다. 하지만 성공적으로 동작하려면 컴포넌트 사이의 의존성 구조를 관리하여 순환이 없도록 해야한다.

* 의존성 순환이 없으면 의존성 관계를 따라가도 최초의 컴포넌트로 되돌아 갈 수 없다.(A->B->C->A로 되돌아갈 수 없다)
* 최소한의 의존성으로 컴포넌트 구조가 만들어졌기 때문에 테스트를 구성할 때 대체로 적은 노력이 들어가고 변수도 상대적으로 적다.
* 시스템 전체를 릴리스해야 할 때가 오면 상향식으로 의존성 끝에 있는 컴포넌트부터 테스트하고 릴리스 한다. 이 절차는 명료하여 쉽게 처리할 수 있다.

#### 순환이 컴포넌트 의존성에 미치는 영향
순환 의존성이 발생할 경우 해당하는 컴포넌트들은 사실상 하나의 거대한 컴포넌트가 된다. 컴포넌트들이 서로에게 얽매이게 되는데, 모두 항상 정확하게 동일한 릴리스를 사용해야 하기 때문이다.

### SDP

### SAP
