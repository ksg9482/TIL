# 개요
좋은 소프트웨어 시스템은 깔끔한 코드에서 시작한다. 이는 좋은 벽돌을 사용하지 않으면 빌딩의 아키텍처가 좋고 나쁨이 별 의미가 없는 것과 같다.   
반대로 좋은 벽돌을 사용해도 빌딩 아키텍처를 엉망으로 만들 수 있다. 그렇기에 좋은 벽돌로 좋은 아키텍처를 정의하는 원칙이 필요하다.   
## SOLID
SOLID 원칙은 중간 수준의 소프트웨어 구조를 정의하는데 도움을 준다.

잘 설계된 중간 수준이란 다음과 같이 되는 것을 말한다.
* 변경에 유연하다.
* 이해하기 쉽다.
* 많은 소프트웨어에서 사용 할 수 있는 컴포넌트의 기반이 된다.

SOLID는 단순히 클래스를 잘짜는 방법이 아니라 '함수와 데이터를 결합한 집합'을 어떻게 잘 설계하느냐를 설명한다.   
이 원칙들은 이미 수많이 설명되었다. 그래서 이 장에서는 이 설명을 되풀이하는 것이 아니라, 이 원칙들이 아키텍처 관점에서 지닌 의미에 집중해 논의하고자 한다.

___
### SRP (Single Responsibility Principle). 단일 책임 원칙
SOLID 원칙 중 의미가 가장 잘 전달되지 못한 원칙이 바로 단일 책임 원칙이다. 아마 프로그래머가 이 원칙을 듣는다면 모듈은 단 하나의 일만 해야한다는 의미로 받아들이기 쉽다.   
하지만 단 하나의 일만 해야한다는 원칙은 따로 있다. 바로 **함수는 단 하나의 일만 해야 한다**는 원칙이다. 

단일 책임 원칙은 '단일 모듈은 변경의 이유가 하나뿐이여야 한다'가 정확한 표현이다. 변경의 이유는 사용자와 이해관계자들 즉, 변경을 요구하는 사람 혹은 집단을 가리킨다.   
소프트웨어 시스템의 최적 구조는 시스템을 만드는 조직의 사회적 구조에 큰 영향을 받는다. 따라서 변경을 요구하는 사람도 이유도 다르다.

이 사람들을 '액터'라고 부른다면 단일 책임 원칙은 아래의 의미를 갖게 된다.
* 하나의 모듈은 오직 **하나의 액터**에 대해서만 책임져야 한다. 

모듈은 함수와 데이터구조로 구성된 응집된 집합이고, 응집된(cohesive)이라는 단어가 단일 책임 원칙을 암시한다.   
단일 액터를 책임지는 코드를 함께 묶어주는 힘이 바로 응집성(cohesion)이다.

이 원칙을 이해하는 가장 좋은 방법은 원칙을 위반하는 징후들을 살펴보는 것이다.

#### 징후 1. 우발적 중복
Employee라는 클래스가 있다고 하자. 이 클래스는 3가지 메서드를 가진다.
* calculatePay() - 회계팀에서 정의하고 CFO 보고를 위해 사용한다. 
* reportHours() - 인사팀에서 정의하고 COO 보고를 위해 사용한다.
* save()  - 데이터 베이스 관리자가 기능을 정리하고 CTO보고를 위해 사용한다.

이 경우 Employee 클래스는 단일 책임 원칙을 위반 했다. 세가지 메서드가 서로 다른 세 액터를 책임지기 때문이다.
세 메서드가 단일 클래스에 배치되었으므로, 이 결합으로 인해 CFO 팀에서 결정한 조치가 COO팀이 의존하는 무언가에 영향을 줄 수 있다.

예를 들어보자.

* 초과 근무를 제외한 업무 시간을 계산하기 위해 regularHours() 라는 메서드가 있다.
* 이 메서드는 급여계산을 위해 calculatePay()메서드와, 업무시간 계산을 위해 reportHours()메서드가 공유한다.
* 그런데 CFO팀에서 업무시간 계산 방식을 수정하기로 결정했고 regularHours() 메서드는 수정되었다.
* COO팀은 업무시간을 다른 목적으로 사용하기에 수정을 원치 않는데, regularHours() 메서드가 수정되었음을 눈치채지 못하여 (수치가 엉망인) 보고서를 생성했다.

이런 상황은 서로 다른 액터가 의존하는 코드를 너무 가까이 배치해서 발생한다. 

그렇기에 SRP는 **서로 다른 액터가 의존하는 코드는 서로 분리하라**고 말한다.
중복된 것처럼 보여도 변경을 요청할 수 있는 액터가 하나가 아니라면 사실은 중복된게 아니다. 무작정 합치지 말고 분리해야 한다.


#### 징후2. 병합
소스파일에 많은 메서드를 포함하면 병합이 자주 발생한다. 특히 메서드가 서로 다른 액터를 책임진다면 병합이 발생할 가능성이 확실히 더 높다.

병합에 위험이 따른다는 것은 말하지 않아도 알 것이다. 어떠한 도구를 사용하여 병합을 해결할 수 있지만 모든 경우를 해결할 수는 없다.   
살펴볼만한 징후가 더 있겠지만 이 징후들은 모두 많은 사람이 서로 다른 목적으로 동일한 소스 파일을 변경하는 경우에 해당한다.   

다시한번 말하지만, 이 문제를 해결하는 방법은 **서로 다른 액터를 뒷바침하는 코드를 서로 분리**하는 것이다.

#### 해결책
문제의 해결책은 다양하지만 그 모두가 결국 메서드를 각기 다른 클래스로 이동시키는 방식이다. 아마 가장 확실한 해결책은 데이터와 메서드를 분리하는 방식일 것이다. 

예를 들자면, 아무런 메서드가 없는 데이터 구조인 EmployeeData 클래스를 만들어 세개의 클래스가 공유하도록 한다. 이 때, 세 클래스는 서로의 존재를 몰라야 한다.   
```javascript
class EmployeeData {};

class PayCalculator extends EmployeeData 
	calculatePay()
};

class HourReporter extends EmployeeData {
	reportHours()
};

class EmployeeSaver extends EmployeeData {
	saveEmployee()
};
```

이 해결책은 개발자가 세 클래스를 인스턴스화 하고 추적해야 한다는 것이 단점이다. 이 경우 흔히 쓰는 기법으로 파사드 패턴이 있다.   
파사드 클래스를 두어 이 클래스는 세 클래스의 객체를 생성하고, 요청된 메서드를 가지는 객체로 위임하는 일을 책임진다.   
또는 가장 중요한 메서드는 기존의 Employee 클래스에 유지하되 Employee 클래스를 덜 중요한 나머지 메서드들에 대한 파사드로 사용할 수 도 있다.   
___

### OCP (Open-Closed Principe). 개방-폐쇄 원칙
버트란트 마이어(Bertrand Meyer)에 의해 유명해진 원칙이다.
* 소프트웨어 개체(artifact)는 확장에는 열려있어야 하고, 변경에는 닫혀있어야 한다.
다시 말해, 소프트웨어 개체의 행위는 확장할 수 있어야 하지만 이 때 산출물을 변경해서는 안된다.

소프트웨어 아키텍처를 공부하는 **가장 근본적인 이유**가 바로 이 때문이다.   
만약 살짝 확장하는데 소프트웨어를 대폭 수정해야 한다면 그 소프트웨어 설계는 엄청난 실패를 맞닥뜨린 것이다.   

개방-폐쇄 원칙을 클래스와 모듈을 설계할 때 도움이 되는 원칙으로 알고있는 사람들이 많지만, 아키텍처 컴포넌트 수준에서 고려하면 훨씬 중요한 의미를 가진다.

#### 사고실험
책임을 분리했다면 그 책임중 하나에서 변경이 발생하더라도 다른 책임은 변경되지 않도록 소스코드 의존성도 확실히 조직해야 한다.

또한 새로 조직화한 구조에서는 행위가 확장될 때 변경이 발생하지 않음을 보장해야 한다.

이런 목적을 달성하려면 처리과정을 **클래스 단위**로 분할하고, 이 클래스들을 **컴포넌트 단위**로 구분해야 한다.

* 예를 들어 Interactor, Controller, Presenter, View, Database로 이루어진 시스템 구조가 있다고 하자. 
  * Interactor는 업무규칙을 포함하고 있다. 즉, 가장 높은 수준의 정책을 포함하고 있기 때문에 우선순위가 가장 높고 다른 모든 것에서 발생한 변경에서 보호되어야 한다.
  * Interactor는 가장 개방-폐쇄 원칙을 잘 준수할 수 있는 곳에 위치하며, Controller, Presenter, View, Database에서 발생한 어떤 변경도 영향을 주어선 안된다. 
* Interactor입장에서 Controller는 부수적이지만, Presenter와 View보다는 중심적인 문제를 담당한다. 
* 마찬가지로 Presenter는 View보다는 중심적인 문제를 처리한다.

보호의 계층구조는 이런 **수준**이라는 개념을 바탕으로 생성된다. 
가장 높은 수준의 개념인 Interactor는 최고의 보호를 받는다. 가장 낮은 수준의 개념인 View는 거의 보호를 받지 못한다.

이것이 아키텍처 수준에서 개방-폐쇄 원칙이 동작하는 방식이다. 

아키텍트는 기능이 **어떻게(what), 왜(why), 언제(when)** 발생하는지에 따라 기능을 분리하고 분리한 기능을 컴포넌트의 계층구조로 조직화 한다.

이와 같이 컴포넌트 계층구조를 조직화하면 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호 할 수 있다.

#### 방향성 제어
컴포넌트를 이루는 구조 중 의존성의 방향을 제어하기 위한 목적을 가진 것도 있다.   
컴포넌트 간에 의존성이 원하지 않는 방향으로 가게 된다면 중간에 컴포넌트를 두어 의존성을 역전시켜야 한다.

#### 정보 은닉
방향성을 제어하기 위한 컴포넌트가 있다면 다른 측면으로는 정보를 은닉하기 위한 인터페이스도 있다. 정보를 은닉하여 컴포넌트가 다른 컴포넌트의 내부에 대해 너무 많이 알지 못하도록 하는 것이다.

정보를 은닉하지 않으면 컴포넌트가 다른 컴포넌트에 추이종속성을 가지게 될 수도 있다.
* 추이종속성은 클래스A가 클래스B에 의존하고 클래스B는 클래스C에, 다시 클래스C는 클래스A에 의존하는 경우를 말한다.
* 만약 클래스 의존성이 이런식으로 순환하게 되면 모든 클래스가 서로 의존하게 되는 문제가 있다.
* 이는 '자신이 직접 사용하지 않는 요소에는 절대로 의존해서는 안된다'는 소프트웨어 원칙을 위반하게 된다.

가장 우선순위가 높은 컴포넌트는 우선순위가 낮은 컴포넌트의 변경에서 보호되어야 하고, 반대로 우선순위가 낮은 컴포넌트라도 우선순위가 높은 컴포넌트의 변경에서 보호되어야 한다. 

이를 위해서 컴포넌트의 내부를 은닉하는 것이다.

#### 개방-폐쇄 원칙의 결론
* 개방-폐쇄 원칙의 목표는 시스템을 확장을 쉽게하는 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는데 있다.
* 이러한 목표를 달성하려면 시스템을 컴포넌트 단위로 분리해야 한다.
* 그리고 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호 할 수 있는 형태의 **의존성 계층구조**가 만들어지도록 해야 한다.

___
### LSP (Liskov substitution Principle). 리스코프 치환 원칙
바바라 리스코프(Babara Liskov)는 하위타입을 다음과 같이 정의했다.
* S타입의 객체 O1에 각각 대응하는 T타입의 객체 O2가 있다.
* T타입을 이용하여 정의한 모든 프로그램 P에서 O2의 자리에 O1을 치환했다.
* 이 때, P의 행위가 변하지 않는다면 S는 T의 하위 타입이다.

상호 대체 가능한 구성 요소를 이용해 소프트웨어 시스템을 만들수 있으려면, 이들 구성 요소는 반드시 서로 치환 가능해야 한다는 계약을 지켜야 한다.

#### 정사각형 / 직사각형 문제
리스코프 치환 원칙을 위반하는 전형적인 문제로는 정사각형 / 직사각형 문제가 있다.   
이 예제에서 정사각형은 직사각형의 하위타입으로 적합하지 않은데, 직사각형의 높이와 너비는 독립적으로 변경될 수 있는 반면, 정사각형의 높이와 너비는 반드시 함께 변경되기 때문이다.   

이런 형태의 리스코프 치환 원칙 위반을 막기 위해선 (⁭if문 등을 이용해서) 직사각형이 실제로는 정사각형인지 검사하는 메커니즘을 클래스 혹은 메서드에 추가해야 한다.   
그러나 이렇게 하면 **행위가 사용하는 타입에 의존**하게 되므로 결국 타입을 서로 치환 할 수 없게 된다.

#### 리스코프 치환 원칙과 아키텍처
객체지향이 등장한 초창기에는 리스코프 치환 원칙이 상속을 사용하도록 가이드하는 방법으로 간주되었으나, 시간이 지나 더 **광범위한 소프트웨어 설계 원칙**으로 변모했다.

자바같은 언어라면 인터페이스 하나와 이를 구현하는 여러 클래스로 구성되고, 루비라면 동일한 메서드 시그니처를 공유하는 여러개의 클래스로 구성된다.   
또는 동일한 REST 인터페이스에 응답하는 서비스 집단일 수 있다.   

이 상황 말고도 더 많은 경우에도 리스코프 치환 원칙을 적용 할 수 있다.

#### 리스코프 치환 원칙의 결론
리스코프 치환 원칙은 **아키텍처 수준까지 확장**할 수 있고, 반드시 확장해야 한다.   
치환 가능성을 위배하면 시스템 아키텍처가 오염되어 상당량의 별도 메커니즘을 추가해야 할 수도 있기 때문이다.
___

### ISP (Interface Segregation Principle) 인터페이스 분리 원칙
인터페이스 분리 원칙은 다음과 같은 상황에서 그 이름이 유래되었다.
* OPS라는 클래스가 있고, 이 클래스에는 op1, op2, op3라는 오퍼레이션이 있다.
* User1은 op1만을 사용하고, User2은 op2만을 사용한다. 마찬가지로 User3은 op3만을 사용한다고 하자.
* OPS가 정적 타입 언어로 작성된 클래스라고 한다면  User1에서는 op2, op3을 전혀 사용하지 않음에도 User1의 소스코드는 이 두 메서드에 의존하게 된다.
* 이런 의존성으로 인해 OPS 클래스에서 op2의 소스코드가 변경되면, User1과 관련된 코드가 변경되지 않았으나 User1도 다시 컴파일하고 새로 배포해야 한다. 

이 원칙에 따르면 소프트웨어 설계자는 사용하지 않는 것에 의존하지 말아야 한다. 이런 문제는 오퍼레이션을 인터페이스 단위로 분리하여 해결 할 수 있다.

#### 인터페이스 분리 원칙과 언어
앞의 사례는 언어타입에 의존한다. 정적 타입 언어는 사용자가 import, use, include와 같은 타입 선언문을 사용하도록 강제한다.   
이처럼 소스코드에 포함된(included) 선언문으로 인해 소스코드 의존성이 발생하고, 이로 인해 재컴파일과 재배포가 강제되는 상황이 무조건 초래된다.   

루비나 파이썬 같은 동적 타입 언어에서는 소스코드에 이러한 선언문이 존재하지 않는다. 대신 런타임에 추론이 발생한다.   
따라서 소스 코드 의존성이 아예 없으며, 결국 재컴파일과 재배포가 필요없다.   
 * 물론 이 부분은 깊게 들어가면 복잡해진다.

동적 타입 언어를 사용하면 정적 타입 언어를 사용할 때 보다 유연하며 결합도가 낮은 시스템을 만들 수 있는 이유는 이 때문이다.   
이러한 사실로 인해 인터페이스 분리 원칙을 아키텍처가 아니라, **언어와 관련된 문제라고 결론내릴 여지**가 있다.

#### 인터페이스 분리 원칙과 아키텍처
일반적으로, 필요 이상으로 많은 걸 포함하는 모듈에 의존하는 것은 해로운 일이다. 소스코드 의존성의 경우 이는 분명한 사실인데, 불필요한 재컴파일과 재배포를 강제하기 때문이다.

심지어 더 고수준인 아키텍처에서도 마찬가지인 상황이 발생 할 수 있다.

* 시스템을 구축하기 위해 어떤 프레임워크를 도입하기로 했다. 이 프레임워크는 특정한 데이터베이스를 사용해야 한다.
* 프페임워크 내부에는 해당 시스템에서는 불필요한 기능이 포함되어 있다고 하자. 이 불필요한 기능이 수정되면 시스템까지 영향을 주어 재배포 해야 할 수도 있다.
* 심각한 경우를 생각해 본다면 데이터베이스의 기능에 문제가 발생했을 때, 심지어 프레임워크와 시스템에서 불필요한 기능이더라도 영향을 줄 수 있다.



#### 인터페이스 분리 원칙의 결론
**불필요한 짐**을 실은 무언가에 의존하면 예상치 못한 문제에 빠지기 쉽다. 
___

### DIP (Dependency Inversion Principle) 의존성 역전 원칙
고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대 의존해선 안된다.
대신 세부사항이 정책에 의존해야 한다.

의존성 역전 원칙이 말하는 유연성이 극대화된 코드는 소스코드 의존성이 **추상(abstruction)에 의존하고 구체(concretion)에 의존하지 않는 시스템**이다.   
정적 타입 언어에서 이 말은 오직 인터페이스나 추상 클래스 같은 추상적인 선언 만을 참조해야 한다는 뜻이다.   
동적타입 언어도 마찬가지인데, 소스코드 의존관계에서 구체 모듈은 참조해선 않된다.   

이 아이디어를 규칙으로 보기에는 비현실적이다. 소프트웨어 시스템인 구체적인 많은 장치에 반드시 의존하기 때문이다. string 클래스는 구체 클래스이지만 매우 안정적이다.    
변경이 거의 없으며 있더라도 엄격히 통제된다. 

이런 이유로 운영체제나 플랫폼 등 안정성이 보장된 환경에 대해서는 무시하는 편이다. 의존하지 않도록 피해야 하는 것은 변동성(volatile)이 큰 구체적인 요소이다.   
즉, 개발중이라 자주 변경될 수 밖에 없는 모듈들이다.

#### 안정된 추상화
안정된 소프트웨어 아키텍처란 변동성이 큰 구현체에 의존하는 일은 지양하고, 안정된 추상 인터페이스를 선호하는 아키텍처를 뜻한다.   
실제로 뛰어난 소프트웨어 설계자와 아키텍트라면 변동성을 낮추기 위해 애쓴다. 또 최대한 변경 없이 구현체에 기능을 추가할 수 있는 방법을 찾기 위해 노력한다.

이는 다음과 같은 구체적인 코딩 실천법으로 요약된다.
* 변동성이 큰 구체 클래스를 참조하지 말라. 대신 추상 인터페이스를 참조하고, 이 규칙은 언어가 정적이든 동적이든 관계없이 적용된다.
  * 또한 이 규칙은 객체 생성 방식을 제약한다. 일반적으로 추상 팩토리를 사용하도록 강제한다.
* 변동성이 큰 구체 클래스로부터 파생하지 말라. 상속은 아주 신중해야 한다. 
  * 정적타입 언어라면 상속은 모든 관계중 가장 강력하기에 변경하기 어렵다. 동적타입 언어도 의존성을 가진다는 사실은 변함이 없다.
* 구체 함수를 오버라이드 하지 말라. 대체로 구체 함수는 소스코드 의존성을 필요로 하고 구체 함수를 오버라이드 하면 의존성을 상속하게 된다.
  * 의존성을 제거하려면 추상 함수로 선언하고 구현체들에서 각자 용도에 맞게 구현해야 한다.
* 구체적이고 변동성이 크다면 절대 쓰지 말라.

#### 팩토리
이 규칙들을 준수하려면 변동성이 큰 구체적인 객체는 주의해서 생성해야 한다. 대다수의 객체지향 언어에서 바람직하지 못한 의존성을 처리할 때 추상 팩토리를 이용하곤 한다.
소스코드 의존성은 추상적인 쪽으로 향하고, 시스템은 **추상 컴포넌트와 구체 컴포넌트로 분리**된다.

#### 구체 컴포넌트
의존성 역전 원칙에 위배된 사항을 모두 없앨 수는 없다. 하지만 위배하는 클래스들은 적은 수의 구체 컴포넌트 내부로 모을 수 있고, 이를 통해 시스템의 나머지 부분과는 분리 할 수 있다.
대다수의 시스템은 이러한 구체 컴포넌트를 최소 하나 포함한다. 

#### 의존성 역전 원칙의 결론
의존성 역전 원칙은 이후로도 여러번 등장한다. 추상과 구체를 분리한 선은 이후 아키텍처의 경계가 될 것이고, 이 선을 경계로 의존성은 더 추상적인 엔티티가 있는 쪽으로만 향한다.
