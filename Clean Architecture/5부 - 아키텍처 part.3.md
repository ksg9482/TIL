# 프레젠터와 험블객체
프레젠터란 험블객체(humble object)패턴을 따른 형태로, 아키텍처 경계를 식별하고 보호하는데 도움이 된다.   

험블객체 패턴이란 디자인 패턴으로, 테스트하기 쉬운 행위와 어려운 행위를 단위 테스트 작성자가 분리하기 쉽게 하는 방법으로 고안되었다.
행위들을 둘로 나눠서 가장 기본적인 본질은 남기고 테스트하기 어려운 행위를 모두 험블 객체로 옮긴다. 나머지 모듈에는 테스트하기 쉬운 행위들을 옮긴다.   

예를 들면, GUI의 경우 단위 테스트가 어렵다. 각 요소가 필요한 위치에 표시되었는지 검사하는 테스트는 작성하기 어렵지만, GUI에서 수행하는 행위의 대다수는 쉽게 테스트 할 수 있다.   
따라서 험블 객체 패턴을 사용하여 프레젠터와 뷰라는 서로 다른 클래스 혹은 모듈로 나눌 수 있다.

뷰는 험블 객체이고 테스트하기 어렵기 때문에 코드를 가능한한 간단하게 유지한다. 뷰는 데이터를 GUI로 이동시키지만, 데이터를 직접 처리하지는 않는다.   

프레젠터는 테스트하기 쉬운 객체이고, 역할은 어플리케이션으로부터 데이터를 받아 화면에 표시 할 수 있는 포맷으로 만든다. 이를 통해 뷰는 데이터를 화면으로 전달하는 간단한 일만 처리하게 한다.

어플리케이션은 데이터를 프레젠터에 전달하고, 프레젠터는 해당 데이터를 적절한 포맷으로 만든다. 이 포맷을 뷰 모델이라 부르는 간단한 데이터구조에 담고, 뷰는 뷰 모델에서 데이터를 찾아 화면에 로드한다.   
이런 식으로 뷰는 데이터를 화면에 로드할 뿐이며 이 외에 맡은 일이 없는, 보잘것 없는(humble) 것이다.

테스트 용이성은 좋은 아키텍처의 속성인 만큼, 행위를 테스트하기 쉬운 부분과 어려운 부분으로 분리하면 아키텍처의 경계가 정의된다. 프레젠터와 뷰 사이의 경계는 이러한 경계중 하나이다.

이런 험블 객체를 만드는 패턴은 데이터베이스나 서비스 리스너 등에도 적용된다. 데이터베이스의 경우 ORM 시스템은 케이트웨이 인터페이스와 데이터베이스 사이에서 일종의 또다른 험블 경계를 형성한다.

경계를 넘나드는 통신은 거의 모두 간단한 데이터 구조를 수반할 때가 많고, 대개 그 경계는 테스트하기 어려운 무언가와 쉬운 무언가로 분리될 것이다. 이러한 아키텍처 경계에서 험블객체 패턴을 사용하면 전체 시스템의 테스트 용이성을 크게 높일 수 있다.

* 외부에서 데이터를 받을때 특정 모듈을 통해 데이터 포맷을 어플리케이션이 사용하기 쉽게 변경한다. 이 모듈은 험블 객체다.
* 어플리케이션이 로드한 데이터를 외부 서비스로 보낼 때도 특정 모듈을 통해 포맷을 변경한다. 이 모듈 또한 험블 객체이다.

# 부분적 경계
아키텍처 경계를 완벽하게 만드는 데는 비용이 많이 든다. 쌍방향의 다형적 인터페이스, input/output을 위한 데이터구조, 격리하고 의존성을 관리하는 것까지 만드는 것 뿐만이 아니라 유지하는데도 비용과 노력이 든다.
이런 경계를 만드는데 너무 부담스럽거나 지금 필요하지 않은 작업이라 판단된다면 부분적 경계를 구현 할 수도 있다.   

## 1. 마지막 단계를 건너뛰기
부분적 경계를 생성하는 방법 하나는 컴포넌트로 격리하기 위한 작업은 모두 수행한 후, 단일 컴포넌트에 그대로 모아만 두는 것이다. 쌍방향 인터페이스, 입/출력 데이터 구조 등 모든 것이 준비되어있지만 분리하지는 않는다.   
완벽한 경계를 만드는 만큼의 코드량과 사전 설계가 필요하지만 다수의 컴포넌트를 관리하는 작업은 하지 않아도 되고 배포 부담도 없다. 이 차이는 가볍지 않다.   

## 2. 일차원 경계
완벽한 형태의 아키텍처 경계는 비용이 많이 든다. 추후 완벽한 형태의 경계로 확장 할 수 있는 공간을 확보하고자 할 때 활용할 수 있는 더 간단한 구조가 일차원 경계이다.    
이는 전통적인 전략(strategy)패턴을 사용한 사례이다. 

Service Impl클래스가 Service Boundary 인터페이스를 구현하고, 클라이언트는 Service Boundary 인터페이스를 사용한다.   
이 방식은 클라이언트를 Service Impl로부터 격리시키는데 필요한 의존성 역전이 적용되어 있다. 하지만 제대로 사용하지 않으면 분리가 쉽게 무너진다.

## 3. 퍼사드
더 단순한 경계는 퍼사드(facade) 패턴이다. 경계는 Facade 클래스로만 간단히 정의되고, 심지어 의존성 역전까지도 희생하여 간단하게 만든다.   
퍼사드 클래스에는 모든 서비스 클래스르 메서드 형태로 정의하고, 서비스 호출이 발생하면 해당 서비스 클래스로 호출을 전달한다. 클라이언트는 서비스 클래스에 직접 접근 할 수 없다.   
하지만 클라이언트가 모든 서비스 클래스에 추이 종속성을 가지게 되는 문제가 있다. 

## 결론
이 세가지 방법말고도 방법은 많다. 이러한 접근법은 각각 나름의 비용과 장점을 지니는데, 적절하게 사용할 수 있는 상황이 서로 다르다.   
또한 각 접근법은 해당 경계가 실제로 구체화되지 않으면 가치가 떨어질 수 있다.

# 계층과 경계
대다수의 시스템에서 컴포넌트의 개수는 많다. 단순히 UI, 업무 규칙, 데이터베이스로만 구성된 것이 아니다.   
시스템이 복잡해질수록 컴포넌트 구조는 더 많은 흐름으로 분리된다. 아키텍처 경계는 어디에나 존재하고, 아키텍처 경계가 언제 필요한지 신중하게 파악해야 한다.

경계를 제대로 구현하려면 비용이 많이 들지만, 이러한 경계를 무시했다가 나중에 다시 추가하는 비용도 크다는 것을 알고 있어야 한다.
보통 오버 엔지니어링이 언더 엔지니어링 보다 나쁠 때가 많기에, YAGNI(필요한 것만을 하라는 뜻)가 말하고자 하는 것을 알아야 하지만, 다른 한편으로는 아키텍처 경계가 없는 상황에서 그때서야 경계를 추가하는 것은 비용이 많이 들고 위험을 감수 해야 한다. 

때문에 현명하게 추측하고, 어디에 아키텍처 경계를 둬야 할지, 구현할 경계는 무엇인지 결정해야 한다. 또, 시스템이 발전함에 따라 변하는 상황도 유심히 살펴야한다.

목표는 경계의 구현비용이, **경계가 존재하지 않아 생기는 마찰의 조짐**을 무시해서 생기는 비용보다 적어지는 그 지점에서 경계를 구현하는 것이다.

# 메인 컴포넌트
모든 시스템에는 최소한 하나의 컴포넌트가 존재하고 이 컴포넌트가 나머지 컴포넌트를 생성하고 조정하며 관리한다. 이 컴포넌트를 메인 컴포넌트라고 부른다. 메인 컴포넌트는 사실 궁극적인 세부사항이며, 가장 낮은 수준의 정책이다. 메인은 시스템의 초기 진입점이며 운영체제를 제외하면 어떤것도 메인에 의존하지 않는다. 시스템 전반을 담당하는 기반을 생성한 후 시스템에서 더 높은 수준을 담당하는 부분으로 제어권을 넘기는 역할을 담당한다.

의존성 주입 프레임워크를 사용한다면 의존성을 주입하는 일은 메인 컴포넌트에서 이뤄져야 한다. 메인에 의존성이 주입되고 나면, 메인은 의존성 주입 프레임워크를 사용하지 않고도 일반적인 방식으로 의존성을 분배할 수 있어야 한다. 

메인을 가장 지저분한 컴포넌트로 생각해도 된다. 클린 아키텍처에서 가장 바깥에 위치하는, 지저분한 저수준 모듈이다. 

## 결론
메인을 어플리케이션의 플러그인리라 생각하자. 초기 조건과 설정을 구성하고 외부 자원을 수집한 후, 제어권을 넘기는 플러그인이다.   

메인을 플러그인 컴포넌트로 여기고 아키텍처 경계 바깥에 위치한다고 생각하면, 설정 관련 문제를 훨씬 쉽게 해결 할 수 있다.

# 크고 작은 모든 서비스들
서비스 지향 아키텍처와 마이크로서비스 아키텍처는 최근에 큰 인기를 끌고 있다.
* 서비스를 사용하면 상호 결합이 철저히 분리되는 것 처럼 보인다.
* 서비스를 사용하면 개발과 배포 독립성을 지원하는 것 처럼 보인다.
과연 그럴까?

## 서비스 아키텍처?
서비스를 사용한다는 것이 본질적으로 아키텍처에 해당하는지 생각해본다면, 이 개념은 명백히 사실이 아니다.  

시스템의 아키텍처는 의존성 규칙을 준수하고 고수준의 정책을 저수준의 세부사항으로부터 분리하는 경계에 의해 정의된다. 단순히 어플리케이션의 행위를 분리할 뿐이라면 그저 값비싼 함수 호출에 불과하다.

결국 서비스는 프로세스나 플랫폼 경계를 가로지르는 함수 호출이다. 아키텍처 적으로 중요한 서비스도 있지만, 중요하지 않은 서비스도 있다.

## 서비스의 이점?
서비스의 이점으로 꼽고 있는 것에서도 오류가 있다.

### 결합 분리의 오류
시스템을 서비스로 분리함으로써 얻게 되리라 예상되는 이점중 하나는 서비스 사이의 결합이 분리된다는 것이다. 이 말은 일리가 있지만 꼭 그렇지만은 않다.
물론 서비스는 개별 변수의 수준에서는 각각 결합이 분리된다. 하지만 프로세서 내의 또는 네트워크 상의 공유 자원 때문에 결합될 가능성이 존재하고 서로 공유하는 데이터에 의해 강력하게 결합된다.

예를 들어 서비스 사이를 오가는 데이터 레코드에 새로운 필드를 추가한다면, 이 필드를 사용하는 모든 서비스는 변경되어야 한다. 즉, 서비스들은 이 데이터 레코드에 강하게 결합되고 서비스들 사이도 간접적으로 결합된다.   

또, 인터페이스가 잘 정의되어 있어야 한다는 이점은 사실이지만 이는 함수의 경우에도 마찬가지다.

### 개발 및 배포 독립성의 오류
전담팀이 서비스를 소유하고 운영한다는 이점이 있고, 때문에 데브옵스 전략의 일환으로 전담팀에서 서비스를 맡는다. 이러한 개발 및 배포 독립성은 확장 가능한(scalable) 것으로 간주된다.   
대규모 엔터프라이즈 시스템도 개발, 유지보수, 운영 또한 독립적인 팀단위로 분할 할 수 있을것이라 기대한다.   

하지만 서비스는 확장 가능한 서비스를 구출하는 유일한 선택지가 아니고, 서비스라고 해도 항상 독립적으로 개발, 배포, 운영할 수 있는 것은 아니다. 데이터나 행위에서 어느정도 결합되어 있다면 결합된 정도에 맞게 개발, 배포, 운영을 조정해야 한다.

## 횡단 관심사
모든 소프트웨어 시스템은 횡단 관심사(cross-cutting concern) 문제에 직면한다. 기능적 분해는 새로운 기능이 기능적 행위를 횡단하는 상황에 매우 취약하다.

컴포넌트 기반 아키텍처에서는 이 문제를 다형적으로 확장할 수 있는 클래스 집합을 생성해 새로운 기능을 처리하도록 하는 것으로 해결했다.   

서비스에서도 마찬가지로 해결할 수 있다. 서비스가 반드시 단일체일 필요는 없다. 서비스는 SOLID 원칙대로 설계할 수 있으며 컴포넌트 구조를 갖출 수도 있다.

아키텍처 경계는 서비스 사이에 있는게 아니라 오히려 서비스를 관통하며 컴포넌트 단위로 분할한다. 횡단관심사 문제를 해결하려면 서비스 내부는 의존성 규칙도 준수하는 컴포넌트 아키텍처로 설계해야 한다.    
이 서비스들은 시스템의 아키텍처 경계를 정의하지 않고, 아키텍처 경계를 정의하는 것은 서비스 내에 위치한 컴포넌트이다.

## 결론
서비스는 시스템의 확장성과 개발 가능성 측면에서 유용하지만, 그 자체로 아키텍처적으로 그리 중요한 요소는 아니다.   
서비스는 단 하나의 아키텍처 경계로 둘러쌓인 단일 컴포넌트로 만들 수 있다. 혹은 여러 아키텍처 경계로 둘러쌓인 다수의 컴포넌트로 만들 수도 있다. 드물게는 클라이언트와 서비스가 강하게 결합되어 아키텍처적으로 아무런 의미가 없을 때도 있다.

# 테스트 경계
테스트는 시스템의 일부이며, 아키텍처에도 관여한다. 아키텍처 관점에서 보면 TDD로 작성된 테스트든 대규모 테스트든 아키텍처적으로 동등하다.   

테스트는 태생적으로 의존성 규칙을 따른다. 의존성은 항상 테스트 대상이 되는 코드를 향하는데, 실제로 테스트는 아키텍처에서 가장 바깥쪽으로 생각해도 된다. 시스템 내부의 어떤 것도 테스트를 의존하지 않지만, 테스트는 항상 아키텍처의 안쪽으로 의존한다.   
또한 테스트는 가장 고립되어 있다. 독립적으로 배포 가능하고, 어떤 사용자도 테스트에 의존하지 않는다. 그렇다고 해서 시스템 컴포넌트가 아니라는 뜻은 아니다.

## 테스트를 고려한 설계
테스트와 시스템의 설계가 잘 통합되지 않으면 테스트는 깨지기 쉬워지고 변경도 어려워진다. 물론 시스템에 강하게 결합된 테스트는 시스템이 변경될때 같이 변경되어야 한다. 만약 시스템의 공통 컴포넌트가 변경되면 수백 수천개의 테스트가 망가지는데, 이런 문제를 깨지기 쉬운 테스트 문제(Fragile Tests Problem)로 알려져있다.   
깨지기 쉬운 테스트는 시스템을 뻣뻣하게 만든다. 시스템에 가한 간단한 변경이 대량의 테스트 실패로 이어진다면 개발자는 그러한 변경을 피하게 될 것이다. 이 문제를 해결하려면 테스트를 고려해서 설계해야 한다.

## 테스트 API
이 목표를 달성하려면 테스트가 모든 업무 규칙을 검증하는데 사용할 수 있도록 특화된 API를 만들면 된다. 보안 제약사항을 무시할 수 있으며, 값비싼 자원(데이터베이스 등)은 건너뛰고, 시스템을 테스트 가능한 특정 상태로 강제하는 강력한 힘을 지녀야 한다.

테스트 API는 테스트를 어플리케이션으로부터 분리할 목적으로 사용한다. 테스트 구조를 어플리케이션 구조로부터 결합을 분리하는 것이 목표다.

## 구조적 결합
구조적 결합은 테스트 결합 중 가장 강하며, 가장 은밀하게 퍼져나가는 유형이다. 모든 상용 클래스에 테스트 클래스가 각각 존재하고, 모든 상용 메서드에 테스트 메서드가 각각 존재한다고 가정하자.   
상용 클래스나 메서드 중 하나라도 변경되면 딸려있는 다수의 테스트가 변경되어야 한다. 결과적으로 테스트는 깨지기 쉬워지고 시스템은 뻣뻣해진다.

테스트 API의 역할은 어플리케이션의 구조를 테스트로부터 숨기는데 있다. 이렇게 만들면 상용코드의 리팩토링이나 발전이 테스트에 영향을 주지 않는다. 이처럼 따로따로 진화 할 수 있다는 점은 필수적이다. 시간이 지날수록 테스트는 더 구체적이고 특화된 형태로 변하지만, 상용 코드는 더 추상적이고 범용적으로 변하기 때문이다.

하지만 구조적 결합이 강하면 이런 진화 과정을 방해하고 상용코드의 범용성과 유연성이 충분히 좋아지지 못하도록 막는다.

## 보안
테스트 API 자체와 테스트 API 중 위험한 부분의 구현부는 독립적으로 배포할 수 있는 컴포넌트로 분리해야 한다. 그래야 위험을 피할 수 있다.

## 결론
테스트에서 기대하는 안정성과 회귀의 이점을 얻으려면 테스트는 시스템의 일부로 잘 설계해야 한다. 그렇지 않으면 테스트의 유지보수가 어려워지고 결국 테스트는 버려지게 된다.

