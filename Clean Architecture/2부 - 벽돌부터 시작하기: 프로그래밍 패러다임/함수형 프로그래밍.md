# 함수형 프로그래밍
여러가지 의미로, 함수형 프로그래밍이라는 개념은 프로그래밍 그 자체보다 앞서 등장했다. 
이 패러다임의 핵심은 람다 계산법이다.

## 불변성
함수형 언어에서 변수는 변경되지 않는다. 변수는 초기화 되면 변하지 않기 때문에, 함수형 언어에는 가변 변수가 없다.
이것이 함수형 언어의 가장 큰 특징인 불변성이다.

가령 반복문을 사용할 경우 자바나 자바스크립트는 이런 식,
```javascript
//JavaScript
for(let i = 0; i < 25; i ++;) {
	console.log(i)
}
```
이와 같이 변수 'i'가 변한다. 변하기 때문에 가변 변수이다.

#### 불변성과 아키텍처
아키텍처를 고려 할 때 왜 이런 내용(변수의 가변성)이 중요할까?
왜냐하면 경합 조건, 교착상태 조건, 동시 업데이트 등의 문제가 전부 가변 변수가 원인으로 발생하기 때문이다. 
만약 어떤 변수도 갱신되지 않는다면 이런 문제가 발생하지 않는다. 

스레드와 프로세스가 여러개인 상황에서도 설계한 시스템이 안정적일 수 있을까? 불변성이 실행 가능할까?
답변은 대체로 긍정적이다. 단, 저장공간과 프로세서의 한계가 없다면 말이다. 

한계가 있다면 일종의 타협을 해야한다.

#### 가변성의 분리
불변성과 관련해 가장 주요한 타협점 중 하나는 어플리케이션 또는 어플리케이션의 내부를 가변 컴포넌트와 불변 컴포넌트로 분리하는 것이다.    

* 불변 컴포넌트에서는 순수하게 함수형 방식으로만 작업을 처리하고, 변수의 상태를 변경할 수 있는 하나 이상의 다른 컴포넌트와 통신한다.    
* 상태 변경은 컴포넌트를 갖가지 동시성 문제에 노출하는 일이므로 흔히 트랜잭션 메모리와 같은 실천법을 사용하여 가변 변수를 보호한다.    
* 트랜잭션 메모리는 DB가 레코드를 다루는 방식과 동일한 방식으로 메모리의 변수를 처라 한다. 즉, 트랜잭션이나 재시도 기법등을 사용한다.    
   
정리하자면, 중요한 것은 어플리케이션을 제대로 구조화하려면 변수를 변경하지 않는 컴포넌트와 변경하는 컴포넌트를 분리하는 일이다.   
그리고 이렇게 분리했으면 가변 변수를 보호하는 적절한 수단으로 뒷받침 해야한다.   
   
가능한 많은 처리를 불변 컴포넌트로 옮겨야 하고, 가변 컴포넌트에서는 가능한 많은 코드를 빼내야 한다.   

#### 이벤트 소싱
저장 공간과 처리 능력의 한계는 급격히 늘어난다. 즉, 저장공간이나 처리능력으로 인해 필요한 가변상태는 더욱 적어진다는 뜻이다.   
   
은행 어플리케이션을 예로 들어보자. 고객의 계좌 잔고를 변경할 때, 잔고를 변경하는 것이 아니라 트랙잭션 자체를 저장한다면?   
잔고 조회를 요청할 때마다 계좌 개설 시점부터 발생한 모든 트랜잭션을 단순히 더한다면, 이 전략에선 가변 변수가 필요 없다.   
   
물론 이런 접근법은 터무니 없다. 그러나 이 전략을 영원히 유지할 필요는 없다.   
어플리케이션의 수명주기 동안만 문제 없이 동작할 저장공간과 처리능력이 있으면 충분하기 때문이다.   
이벤트 소싱에 깔려있는 기본 발상이 바로 이것이다.   
   
상태가 필요해지면 단순히 상태의 시작점부터 모든 트랜잭션을 처리한다.   
   
지름길을 택할 수도 있다.   
매일 자정에 상태를 계산한 후 값을 저장하고 상태가 필요하면 자정 이후의 트랜잭션만을 처리하면 된다.

#### 어디에 쓰이는가?
데이터 저장소에 쓰인다. 저장 공간이 많이 필요하지만, 이미 저장 공간은 급속도로 커지고 있다.   
이 전략(데이터의 CRUD중 CR만 사용)을 사용하면 저장소에 수정과 삭제가 발생하지 않으니 동시 업데이트 문제도 발생하지 않는다.   
저장공간과 처리능력이 충분하다면 어플리케이션이 완전한 불변성을 갖도록 할 수 있고, 완전한 함수형으로 만들 수 있다.
   
터무니없게 들리는가? 하지만 소스 코드 버전 관리 시스템이 정확히 이 방식으로 동작한다.   

### 함수형 프로그래밍의 결론
함수형 프로그래밍은 변수 할당에 규칙을 부과한다.   
   
앞선 프로그래밍 패러다임들과 합쳐서 생각해보면 이 세 패러다임은 전부 '규칙'을 부과하고, 코드를 작성하는 방식의 형태를 한정시킨다.   
새로운 무언가를 알게 된 것이 아니라, '해선 않되는 것'들에 대해 알게된 셈이다.   
   
이는 우리에게 거의 최초의 코드를 작성할 때의 소프트웨어 규칙과 지금의 소프트웨어 규칙은 조금도 다르지 않다는 것을 알려준다.   
즉, 여전히 프로그래밍의 핵심은 순차, 분기, 반복, 참조로 구성되어 있다.   
