## 구조적 프로그래밍
### 구조적 프로그래밍의 탄생
에츠허르 비버 데이크스트라라는 사람이 있다. 그는 네덜란드 최초의 프로그래머였고, 프로그래밍의 원리나 과학을 증명하려 했다.   

이 당시 프로그래밍이란 종이테이프나 천공카드를 이용해 입력하고 처리는 바이너리 또는 기계어를 이용해 수행하는 일이었다.   

수정, 컴파일, 테스트를 반복하는 일은 최소 몇 시간에서 며칠이 걸렸다.   
   
### goto문의 해로움
데이크스트라는 프로그래밍은 어렵고, 프로그래머는 프로그래밍을 잘하지 못한다는 문제를 인식했다.   

모든 프로그램은 단순해도 인간의 두뇌로 감당하기에는 너무 많은 세부사항을 담고 있었다. 아주 작은 세부사항이라도 간과하면 프로그램은 실패하곤 했다.   
   
그는 **증명**이라는 수학적인 원리를 적용하여 이 문제를 해결하고자 했다.    

공리, 정리 등으로 구성되는 유클리드 계층구조를 만드는 것을 목적으로 삼았는데, 이는 프로그래머는 입증된 구조를 이용하고 이 구조를 코드와 결합시키며, 그래서 코드가 **올바르다**는 사실을 스스로 증명하게 되는 방식이었다. 
   
이 연구를 진행하면서 goto 문장이 모듈을 더 작은 단위로 재귀적으로 분해하는 과정에 방해가 되는 경우가 있다는 사실을 발견했다.   

만약 모듈을 분해 할 수 없다면 분할 정복 접근법을 사용 할 수 없게 된다.   
   
반대로 goto문을 사용하더라도 모듈을 분해할 때 방해가 되지 않는 경우도 있었다.   

이 경우는 'if/then/else'와 'do/while'과 같은 분기와 반복이라는 단순한 **제어구조**에 해당함을 발견했다.
   
이런 발견은 곧, 모듈을 증명가능하게 만드는 제어구조가 모든 프로그램을 만들 수 있는 제어구조의 최소 집합과 동일하다는 사실의 발견이었고, 그 최소 집합이란 각각 **순차(sequence), 분기(selection), 반복(iteration)**이었다.   
   
* 순차 - 단순한 열거법을 통해 순차구문의 올바름을 입증할 수 있음을 보여주었다. 이 기법에서는 입력부터 출력까지 수학적으로 추적한다. 이 접근법은 일반적인 수학적 증명방식과 다를 바 없다.
* 분기 - 열거법을 재적용하는 방식으로 처리했다. 분기를 통한 각 경로를 열거하고, 결과적으로 두 경로가 수학적으로 적절한 결과를 만들어 낸다면 증명은 신뢰할 수 있게 된다.
* 반복 - 귀납법을 이용하여 반복이 올바름을 증명했다. 
  * 열거법에 따라 1의 경우가 올바름을 증명했고, N의 경우가 올바르다고 가정할 때 N+1의 경우도 올바름을 증명하며, 이 경우에도 열거법을 사용했다.
  
맨처음 goto문의 해로움과 세가지 제어구조(순차, 분기, 반복)에 대해 발표했을 때, 프로그래밍 세계는 많은 논쟁이 일어났으나 결국 데이크스트라가 옳았다는 결론이 내려졌다.   
   
컴퓨터 언어가 진화하면서 goto문은 계속 뒤로 밀려났고, 현재 대부분의 현대적인 언어는 goto문을 포함하지 않게된 것이다.   

심지어 goto문을 여전히 지원하는 언어에서도 goto문의 목적지 범위를 현재 함수 안으로 한정시키는 편이다.   
   
### 기능적 분해
구조적 프로그래밍을 통해 모듈을 증명 가능한 더 작은 단위로 분해할 수 있다는 뜻은, 결국 모든 모듈을 기능적으로 분해할 수 있음을 뜻한다.   

거대한 문제가 있어도 문제를 고수준의 기능들로 분해하고, 다시 저수준의 함수들로 분해할 수 있다.   

이런 과정을 끝없이 반복해서 분해한 기능들은 구조적 프로그래밍의 제한된 제어구조를 이용하여 표현 할 수 있다.   
   
이를 토대로 구조적 분석, 구조적 설계와 같은 기법이 널리 퍼졌고 또 개선되었다.   

이런 기법을 사용하면 프로그래머는 대규모 시스템을 모듈과 컴포넌트로 나눌 수 있고, 더 나아가 모듈과 컴포넌트는 입증할 수 있는 작은 기능들로 세분화 할 수 있다.   
   
### 테스트
프로그램 관점에서 유클리드 계층구조는 결국 만들어지지 않았다. 수학적으로 프로그래밍을 증명하겠다는 데이크스트라의 비전은 이루어지지 않은 셈이다.   

그러나 무언가가 올바른지 입증할 때 사용하는 전략은 엄밀한 수학적 증명만이 있는 것이 아니었다.   

프로그램에 도입된 것은 과학적 방법이었고, 과학은 근본적으로 수학과 달랐다.   

* 과학 이론과 법칙을 시연하고 극도로 높은 정확도로 측정할 수 있지만, 올바름을 증명할 수 없다.   

* 실험을 아무리 많이 수행해도 다른 실험을 통해 법칙이 잘못되었음이 밝혀질 가능성이 있다. 즉, 과학은 반증은 가능하나 증명은 불가능하다.   
   
* 과학은 서술된 내용이 틀렸음을 증명하는 방식으로 동작하고, 반례를 들 수 없는 서술이 있다면 목표에 부합할 만큼은 참이라고 본다.   

이런 과학적 방법처럼, 프로그램이 잘못되었다는 테스트를 작성하고 그 테스트들을 통과하는 일은 프로그램이 목표에 부합할 만큼은 충분히 참이라고 여길 수 있게 해준다.   
   
### 구조적 프로그래밍의 결론
구조적 프로그래밍은 프로그램을 증명 가능한 세부 기능 집합으로 분해 할 것을 강요한다.   

그리고 테스트를 통해 분해한 기능들이 거짓인지 증명하려고 시도하고, 시도들이 실패하면 이 기능들은 목표에 부합할 만큼은 충분히 참이라고 여긴다.   
   
구조적 프로그래밍이 오늘날에도 가치를 갖는 이유는 프로그래밍에서 **반증 가능한 단위**를 만들어 낼 수 있는 이런 능력 때문이다.   

뿐만아니라 아키텍처 관점에서는 기능적 분해를 최고의 실천법 중 하나로 여기는 이유이기도 하다.   
   
가장 작은 기능에서 부터 가장 큰 컴포넌트 까지, 소프트웨어 아키텍처는 반증 가능하도록(**테스트**하기 쉽도록) 만들기 위해 노력해야 한다.    

이를 위해서는 구조적 프로그래밍과 유사한 제한적인 규칙들을 받아들여 활용해야 한다.
