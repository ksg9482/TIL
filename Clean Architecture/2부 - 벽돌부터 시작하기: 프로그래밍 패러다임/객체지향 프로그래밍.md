# 객체지향 프로그래밍
좋은 아키텍처를 만드는 일은 객체지향 설계 원칙을 이해하고 응용하는 데서 출발한다. 그렇다면 객체지향이란 무엇인가?
* 데이터와 함수의 조합
  * 대체적으로 이런 방식으로 설명되지만 만족스러운 대답은 아니다. 
  * 객체지향 프로그래밍이 발명되기 전부터 프로그래머는 데이터 구조를 함수에 전달해 왔다.
* 실제 세계를 모델링하여 프로그램을 더 쉽게 이해하기 위한 방법
  * 이 말이 무슨 의미인지, 왜 이 방향을 추구해야 하는지 불분명하다.
* 캡슐화, 상속, 다형성 이 세가지 개념을 적절하게 조합한 것이다.
 * 이 세가지 개념도 객체지향을 확실하게 설명해주지 않는다.

## 캡슐화
객체지향을 정의하는 요소중 하나로 캡슐화를 언급하는 이유는, 데이터와 함수를 쉽고 효과적으로 캡슐화하는 방법을 객체지향 언어가 제공하기 때문이다.

그리고 이를 통해 데이터와 함수가 높은 응집도로 구성된 집단을 서로 **구분**지을 수 있다.

이 구분선 바깥에서 데이터는 은닉되고, 일부 함수만이 외부에 노출된다. 이 것들은 각각 클래스의 private 멤버 데이터와 public 멤버 함수로 표현된다.

그런데 이런 캡슐화의 개념이 객체지향에만 국한된 것은 아니다. 

다른 언어에서도 접근할 수 있는 함수와, 접근할 수 없는 데이터나 함수를 나눠서 외부에서 모르게 할 수 있다.

객체지향 프로그래밍은 프로그래머가 올바르게 행동하여, 캡슐화된 데이터를 우회해서 사용하지 않을 것이라는 믿음을 기반으로 한다. 

그리고 사실 많은 객체지향 언어가 캡슐화를 강제하지 않고, 언어의 기술적인 이유나 구현방법으로 인해 캡슐화가 약화된 것은 사실이다. 

따라서 객체지향은 강력한 캡슐화에 의존한다는 정의는 받아들이기 힘들다. 

## 상속 
상속이란 어떤 변수와 함수를 하나의 유효범위로 묶어서 **재정의** 하는 일이다. 

하지만 예전부터 프로그래머는 객체지향 언어의 도움 없이 이런 방법을 구현 할 수 있었다.

물론 객체지향 프로그래밍으로 고안된 상속을 이용하는 것보다 불편하긴 했다. 

상속을 흉내내는 요령은 있었지만 상속만큼 편리한 방법은 아니었고, 이 기법을 이용해서 다중 상속을 구현하는 것은 훨씬 더 어려운 일이었다.

따라서 객체지향 언어가 완전히 새로운 개념을 만들지는 못했지만 데이터구조에 가면을 씌우는 일을 상당히 편리하게 만들어주었다고 할 수 있다.

## 다형성
객체지향 언어가 있기 전에 다형성을 지원했는가? 답은 '그렇다'이다.

다형성은 함수를 가리키는 포인터를 응용한 것이다. 

객체지향의 다형성은 이전에 없던 다형성이란 개념을 제공해주는 것이 아니라, 다형성을 좀 더 **안전하고 편리하게** 사용할 수 있게 해주는 것이다.

함수에 대한 포인터를 직접 사용하여 다형적 행위를 만드는 방식은 위험하고, 이런 기법은 프로그래머가 특정 관례를 수동으로 따르는 방식이다. 

즉, 관례의 일부를 망각하면 버그가 발생하고 이렇게 발생한 버그는 찾기도 고치기도 힘들다.

객체지향 언어는 이런 관례를 없애주어서 실수하지 않도록 해준다. 

따라서 객체지향 프로그래밍은 **제어흐름을 간접적으로 전환하는 규칙**을 부과한다고 할 수 있다. 

### 의존성
다형성을 안전하고 편리하게 적용할 수 있는 메커니즘이 등장하기 전 소프트웨어는 어떤 모습이었을까?

전형적인 호출트리를 생각해보면 main함수가 고수준 함수를, 고수준 함수가 중간수준 함수를, 중간수준 함수는 다시 저수준 함수를 호출한다.

이런 호출트리에서는 소스코드 의존성의 방향은 제어흐름을 따른다. 

하지만 다형성이 끼어들면 상황이 바뀐다.

다형성이 끼어들면 소스코드의 의존성이 제어흐름과 반대가 될 수 있다. 이는 다형성을 안전하고 편리하게 제공한다면 소스코드의 의존성을 어디에서든 역전 시킬 수 있다는 뜻이다.

프로그래머는 호출하는 모듈이든 호출받는 모듈이든 관계없이 소스코드 의존성을 원하는 방향으로 설정 할 수 있다.

그렇다면 이 다형성으로 무엇을 할 수 있을까?

컴포넌트를 개별적이며 독립적으로 배포할 수 있게 만들 수 있다.

특정 컴포넌트의 소스코드가 변경되면 해당 코드가 포함된 컴포넌트만 재배포 하면 된다. 이것이 **배포 독립성**이다.

시스템의 모듈을 독립적으로 배포 할 수 있게 되면, 서로 다른 팀에서 각 모듈을 독립적으로 개발 할 수 있게 된다. 이것이 **개발 독립성**이다.


## 객체지향 프로그래밍의 결론
소프트웨어 아키텍처의 관점에서 객체지향이란 무엇인가에 대한 답변을 내리자면, 객체지향이란 다형성을 이용하여 전체 시스템의 모든 소스코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다.

객체지향을 사용하면 아키텍트는 플러그인 아키텍처를 구성할 수 있고, 이를 통해 고수준의 정책을 포함하는 모듈은 저수준의 세부사항을 포함하는 모듈에 대해 독립성을 보장할 수 있다.

저수준의 세부사항은 중요도가 낮은 플러그인 모듈로 만들 수 있고, 고수준의 정책을 포함하는 모듈과는 독립적으로 개발하고 배포 할 수 있다.
